{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion: Analysis of Range Dependence on Launch Angle 1. Theoretical Foundation Projectile motion is governed by Newton\u2019s laws. Assuming no air resistance, the motion can be described using kinematic equations: Horizontal motion: \\[ x = v_0 \\cos(\\theta) t \\] Vertical motion: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ The total time of flight is found by solving for when the projectile returns to its initial height: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ The horizontal range is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range The horizontal range depends on: Launch Angle (\u03b8): The range is maximized at \\[ 45^\\circ \\] **Initial Velocity \\[ ( v_0 ) \\] :** Higher velocity increases range quadratically. Gravitational Acceleration (g): A stronger gravitational field decreases range. 3. Practical Applications Sports: Understanding ball trajectories in football and basketball. Engineering: Designing projectile-based systems like rockets or artillery. Astrophysics: Studying planetary motion under different gravity levels. 4. Implementation: Python Simulation We use Python to visualize how range varies with launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees angles_rad = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity in m/s^2 projectile_range(v0, g) 5. Discussion on Limitations Air Resistance: In real scenarios, drag significantly reduces range. Uneven Terrain: Changes in landing elevation affect results. Wind Influence: Can alter trajectory unpredictably. Conclusion This analysis demonstrates the relationship between launch angle and range, emphasizing its significance in various real-world applications. Future studies can incorporate drag forces for more realistic modeling. \ud83d\ude80 Why is the Maximum Range Achieved at a 45\u00b0 Angle? \ud83d\udccc Range Formula and Maximum Point The total horizontal distance ( range ) covered by a projectile depends on the launch angle and is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Where: - R = Range (total horizontal distance covered) - v\u2080 = Initial velocity - \u03b8 = Launch angle - g = Gravitational acceleration - sin(2\u03b8) = Function determining the impact of angle on range To achieve maximum range, the function sin(2\u03b8) must be maximized . In mathematics, sin(x) reaches its maximum value when it equals 1 , meaning: \\[ \\sin(2\\theta) = 1 \\Rightarrow 2\\theta = 90 \\] From this: \\[ \\theta = 45 \\] \ud83c\udfaf Conclusion: The maximum range is achieved at a 45\u00b0 launch angle! \ud83e\uddd0 Why Are Lower and Higher Angles Worse? Let's analyze how a projectile behaves at different angles: \ud83d\udd3b Lower Angles (0\u00b0 - 45\u00b0) More horizontal velocity but weaker vertical motion. The projectile falls quickly to the ground, reducing range. For example, a launch at 30\u00b0 provides some range but falls short due to early descent. \ud83d\udd3a Higher Angles (45\u00b0 - 90\u00b0) More vertical velocity but less horizontal velocity. The projectile reaches a higher altitude but does not travel far. For instance, a launch at 60\u00b0 results in a longer air time, but the horizontal distance is shorter due to reduced horizontal speed. \ud83d\udccc The 45\u00b0 angle provides the best balance! \ud83c\udfad Interesting and Fun Facts \ud83c\udfbe The 45\u00b0 Rule in Sports In sports like football, basketball, or tennis, players aim for a 45\u00b0 angle to maximize projectile distance . However, due to air resistance, an optimal angle in practice is usually around 40\u00b0 - 43\u00b0 . \ud83d\ude80 NASA and Rocket Science Space rockets are not launched at exactly 45\u00b0 because they need to escape the atmosphere efficiently. However, artillery shells and short-range missiles often use the 45\u00b0 angle for maximum range! \ud83c\udff9 Archery and Ballistic Missiles Archers aim close to 45\u00b0 when trying to achieve the longest possible shot . Military artillery uses this angle to maximize impact distance . \ud83d\udcca Python Simulation: Effect of Angle on Range The following Python code calculates the range for different angles and plots the results: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s', color='b') plt.axvline(45, color='r', linestyle='--', label='Maximum Range: 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s\u00b2) projectile_range(v0, g) \ud83d\udcc8 What Will the Graph Show? X-axis : Launch angle (in degrees) Y-axis : Range (in meters) Red dashed line : Maximum range at 45\u00b0 Blue curve : Effect of angle on range \ud83d\ude80 CONCLUSION \u2705 The 45\u00b0 angle is the ideal angle for maximum range! \u2705 It provides the best balance between horizontal and vertical velocity. \u2705 In real-world scenarios, air resistance can slightly modify the optimal angle. \u2705 Used in physics, sports, military engineering, and rocket science! \ud83c\udfaf\ud83d\udd25 Yatay Hareket / Horizontal Movement If there is no friction, the speed remains constant. Dikey Hareket / Vertical Movement Speed decreases due to gravity and then reverses. As a result, the object follows a parabolic path and falls to the ground after traveling a certain distance. In this work, we examine the relationship between the launch angle and the distance reached by the object. Our goal is to find out how far the object travels and discover which angle provides the best range. The important factors are: Throw angle affects range! As speed increases, so does range. For best range, we should select forty-five degrees ( \\(45^\\circ\\) ). The \\(45^\\circ\\) angle best balances both horizontal and vertical movement and provides the longest range. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 800 # Bullet initial velocity (m/s) angles = np.arange(10, 21, 2) # Shooting angles (between 10\u00b0 and 20\u00b0 with 2\u00b0 increments) # Function to calculate range def calculate_range(v0, angle): theta = np.radians(angle) return (v0 ** 2) * np.sin(2 * theta) / g # Calculate range for given angles ranges = [calculate_range(v0, angle) for angle in angles] # Plot the graph plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, marker='o', linestyle='-', color='b', label='Bullet Range') plt.xlabel('Shooting Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Range vs. Shooting Angle') plt.legend() plt.grid() plt.show() Differential Equations of Bullet Motion Bullet motion can be modeled in two dimensions: Horizontal motion: $$ \\frac{dx}{dt} = v_x = v_0 \\cos(\\theta) $$ Vertical motion: $$ \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_y}{dt} = -g $$ Where: - x ) and \\( y \\) are the position coordinates of the bullet. - \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components, respectively. - \\( g \\) is the gravitational acceleration. - \\( \\theta \\) is the shooting angle. To solve these differential equations, numerical methods (such as the Euler method) can be used. import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, h0, g=9.81, dt=0.01): theta = np.radians(theta) v0x = v0 * np.cos(theta) v0y = v0 * np.sin(theta) t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g * 2 t = np.arange(0, t_flight, dt) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 y = np.maximum(y, 0) # Ensure it doesn't go below ground return x, y # Define initial velocities, angles, and launch heights v0 = 50 # Initial velocity in m/s theta = 45 # Launch angle in degrees heights = [0, 10, 20] # Different launch heights # Plot the projectile motion for different launch heights plt.figure(figsize=(8, 6)) colors = ['red', 'purple', 'blue'] for h, color in zip(heights, colors): x, y = projectile_motion(v0, theta, h) plt.plot(x, y, label=f\"h0 = {h} m\", color=color) plt.axhline(0, color='black', linewidth=1) # Ground line plt.xlabel(\"Range (m)\") plt.ylabel(\"Height (m)\") plt.title(\"Projectile Motion at Different Initial Heights\") plt.legend() plt.grid() plt.show() import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, g=9.81, dt=0.01): \"\"\"Compute projectile motion given initial velocity and angle.\"\"\" theta = np.radians(theta) v0x = v0 * np.cos(theta) v0y = v0 * np.sin(theta) t_flight = (2 * v0y) / g t = np.arange(0, t_flight, dt) x = v0x * t y = v0y * t - 0.5 * g * t**2 return x, y # Define initial velocities and angles for both plots velocities_a = [30, 40, 50] angles_a = [45, 45, 45] velocities_b = [50, 50, 50] angles_b = [15, 45, 75] # Create figure and subplots fig, axs = plt.subplots(2, 1, figsize=(8, 10)) colors = ['red', 'purple', 'green'] def plot_projectiles(ax, velocities, angles, colors): for v0, theta, color in zip(velocities, angles, colors): x, y = projectile_motion(v0, theta) ax.plot(x, y, color=color, label=f'v0 = {v0} m/s, {theta}\u00b0') ax.axhline(0, color='black', linewidth=1) # Ground line ax.set_xlabel(\"Range (m)\") ax.set_ylabel(\"Height (m)\") ax.legend() ax.grid() # Plot (a) plot_projectiles(axs[0], velocities_a, angles_a, colors) axs[0].set_title(\"(a) Projectile motion with different velocities at 45\u00b0\") # Plot (b) plot_projectiles(axs[1], velocities_b, angles_b, colors) axs[1].set_title(\"(b) Projectile motion with 50 m/s at different angles\") plt.tight_layout() plt.show() My Colab visit website","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-of-range-dependence-on-launch-angle","text":"","title":"Projectile Motion: Analysis of Range Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by Newton\u2019s laws. Assuming no air resistance, the motion can be described using kinematic equations: Horizontal motion: \\[ x = v_0 \\cos(\\theta) t \\] Vertical motion: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ The total time of flight is found by solving for when the projectile returns to its initial height: $$ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} $$ The horizontal range is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The horizontal range depends on: Launch Angle (\u03b8): The range is maximized at \\[ 45^\\circ \\] **Initial Velocity \\[ ( v_0 ) \\] :** Higher velocity increases range quadratically. Gravitational Acceleration (g): A stronger gravitational field decreases range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding ball trajectories in football and basketball. Engineering: Designing projectile-based systems like rockets or artillery. Astrophysics: Studying planetary motion under different gravity levels.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"We use Python to visualize how range varies with launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) # Angles in degrees angles_rad = np.radians(angles) # Convert to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity in m/s g = 9.81 # Gravity in m/s^2 projectile_range(v0, g)","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion-on-limitations","text":"Air Resistance: In real scenarios, drag significantly reduces range. Uneven Terrain: Changes in landing elevation affect results. Wind Influence: Can alter trajectory unpredictably.","title":"5. Discussion on Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis demonstrates the relationship between launch angle and range, emphasizing its significance in various real-world applications. Future studies can incorporate drag forces for more realistic modeling.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#why-is-the-maximum-range-achieved-at-a-45-angle","text":"","title":"\ud83d\ude80 Why is the Maximum Range Achieved at a 45\u00b0 Angle?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-formula-and-maximum-point","text":"The total horizontal distance ( range ) covered by a projectile depends on the launch angle and is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Where: - R = Range (total horizontal distance covered) - v\u2080 = Initial velocity - \u03b8 = Launch angle - g = Gravitational acceleration - sin(2\u03b8) = Function determining the impact of angle on range To achieve maximum range, the function sin(2\u03b8) must be maximized . In mathematics, sin(x) reaches its maximum value when it equals 1 , meaning: \\[ \\sin(2\\theta) = 1 \\Rightarrow 2\\theta = 90 \\] From this: \\[ \\theta = 45 \\] \ud83c\udfaf Conclusion: The maximum range is achieved at a 45\u00b0 launch angle!","title":"\ud83d\udccc Range Formula and Maximum Point"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#why-are-lower-and-higher-angles-worse","text":"Let's analyze how a projectile behaves at different angles:","title":"\ud83e\uddd0 Why Are Lower and Higher Angles Worse?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#lower-angles-0-45","text":"More horizontal velocity but weaker vertical motion. The projectile falls quickly to the ground, reducing range. For example, a launch at 30\u00b0 provides some range but falls short due to early descent.","title":"\ud83d\udd3b Lower Angles (0\u00b0 - 45\u00b0)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#higher-angles-45-90","text":"More vertical velocity but less horizontal velocity. The projectile reaches a higher altitude but does not travel far. For instance, a launch at 60\u00b0 results in a longer air time, but the horizontal distance is shorter due to reduced horizontal speed. \ud83d\udccc The 45\u00b0 angle provides the best balance!","title":"\ud83d\udd3a Higher Angles (45\u00b0 - 90\u00b0)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#interesting-and-fun-facts","text":"","title":"\ud83c\udfad Interesting and Fun Facts"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-45-rule-in-sports","text":"In sports like football, basketball, or tennis, players aim for a 45\u00b0 angle to maximize projectile distance . However, due to air resistance, an optimal angle in practice is usually around 40\u00b0 - 43\u00b0 .","title":"\ud83c\udfbe The 45\u00b0 Rule in Sports"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#nasa-and-rocket-science","text":"Space rockets are not launched at exactly 45\u00b0 because they need to escape the atmosphere efficiently. However, artillery shells and short-range missiles often use the 45\u00b0 angle for maximum range!","title":"\ud83d\ude80 NASA and Rocket Science"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#archery-and-ballistic-missiles","text":"Archers aim close to 45\u00b0 when trying to achieve the longest possible shot . Military artillery uses this angle to maximize impact distance .","title":"\ud83c\udff9 Archery and Ballistic Missiles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation-effect-of-angle-on-range","text":"The following Python code calculates the range for different angles and plots the results: import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, g): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.figure(figsize=(8,5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s', color='b') plt.axvline(45, color='r', linestyle='--', label='Maximum Range: 45\u00b0') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() # Example parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s\u00b2) projectile_range(v0, g)","title":"\ud83d\udcca Python Simulation: Effect of Angle on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#what-will-the-graph-show","text":"X-axis : Launch angle (in degrees) Y-axis : Range (in meters) Red dashed line : Maximum range at 45\u00b0 Blue curve : Effect of angle on range","title":"\ud83d\udcc8 What Will the Graph Show?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion_1","text":"\u2705 The 45\u00b0 angle is the ideal angle for maximum range! \u2705 It provides the best balance between horizontal and vertical velocity. \u2705 In real-world scenarios, air resistance can slightly modify the optimal angle. \u2705 Used in physics, sports, military engineering, and rocket science! \ud83c\udfaf\ud83d\udd25","title":"\ud83d\ude80 CONCLUSION"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#yatay-hareket-horizontal-movement","text":"If there is no friction, the speed remains constant.","title":"Yatay Hareket / Horizontal Movement"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#dikey-hareket-vertical-movement","text":"Speed decreases due to gravity and then reverses. As a result, the object follows a parabolic path and falls to the ground after traveling a certain distance. In this work, we examine the relationship between the launch angle and the distance reached by the object. Our goal is to find out how far the object travels and discover which angle provides the best range.","title":"Dikey Hareket / Vertical Movement"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#the-important-factors-are","text":"Throw angle affects range! As speed increases, so does range. For best range, we should select forty-five degrees ( \\(45^\\circ\\) ). The \\(45^\\circ\\) angle best balances both horizontal and vertical movement and provides the longest range. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Gravitational acceleration (m/s^2) v0 = 800 # Bullet initial velocity (m/s) angles = np.arange(10, 21, 2) # Shooting angles (between 10\u00b0 and 20\u00b0 with 2\u00b0 increments) # Function to calculate range def calculate_range(v0, angle): theta = np.radians(angle) return (v0 ** 2) * np.sin(2 * theta) / g # Calculate range for given angles ranges = [calculate_range(v0, angle) for angle in angles] # Plot the graph plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, marker='o', linestyle='-', color='b', label='Bullet Range') plt.xlabel('Shooting Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Range vs. Shooting Angle') plt.legend() plt.grid() plt.show()","title":"The important factors are:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#differential-equations-of-bullet-motion","text":"Bullet motion can be modeled in two dimensions: Horizontal motion: $$ \\frac{dx}{dt} = v_x = v_0 \\cos(\\theta) $$ Vertical motion: $$ \\frac{dy}{dt} = v_y $$ $$ \\frac{dv_y}{dt} = -g $$ Where: - x ) and \\( y \\) are the position coordinates of the bullet. - \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components, respectively. - \\( g \\) is the gravitational acceleration. - \\( \\theta \\) is the shooting angle. To solve these differential equations, numerical methods (such as the Euler method) can be used. import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, h0, g=9.81, dt=0.01): theta = np.radians(theta) v0x = v0 * np.cos(theta) v0y = v0 * np.sin(theta) t_flight = (v0y + np.sqrt(v0y**2 + 2 * g * h0)) / g * 2 t = np.arange(0, t_flight, dt) x = v0x * t y = h0 + v0y * t - 0.5 * g * t**2 y = np.maximum(y, 0) # Ensure it doesn't go below ground return x, y # Define initial velocities, angles, and launch heights v0 = 50 # Initial velocity in m/s theta = 45 # Launch angle in degrees heights = [0, 10, 20] # Different launch heights # Plot the projectile motion for different launch heights plt.figure(figsize=(8, 6)) colors = ['red', 'purple', 'blue'] for h, color in zip(heights, colors): x, y = projectile_motion(v0, theta, h) plt.plot(x, y, label=f\"h0 = {h} m\", color=color) plt.axhline(0, color='black', linewidth=1) # Ground line plt.xlabel(\"Range (m)\") plt.ylabel(\"Height (m)\") plt.title(\"Projectile Motion at Different Initial Heights\") plt.legend() plt.grid() plt.show() import numpy as np import matplotlib.pyplot as plt def projectile_motion(v0, theta, g=9.81, dt=0.01): \"\"\"Compute projectile motion given initial velocity and angle.\"\"\" theta = np.radians(theta) v0x = v0 * np.cos(theta) v0y = v0 * np.sin(theta) t_flight = (2 * v0y) / g t = np.arange(0, t_flight, dt) x = v0x * t y = v0y * t - 0.5 * g * t**2 return x, y # Define initial velocities and angles for both plots velocities_a = [30, 40, 50] angles_a = [45, 45, 45] velocities_b = [50, 50, 50] angles_b = [15, 45, 75] # Create figure and subplots fig, axs = plt.subplots(2, 1, figsize=(8, 10)) colors = ['red', 'purple', 'green'] def plot_projectiles(ax, velocities, angles, colors): for v0, theta, color in zip(velocities, angles, colors): x, y = projectile_motion(v0, theta) ax.plot(x, y, color=color, label=f'v0 = {v0} m/s, {theta}\u00b0') ax.axhline(0, color='black', linewidth=1) # Ground line ax.set_xlabel(\"Range (m)\") ax.set_ylabel(\"Height (m)\") ax.legend() ax.grid() # Plot (a) plot_projectiles(axs[0], velocities_a, angles_a, colors) axs[0].set_title(\"(a) Projectile motion with different velocities at 45\u00b0\") # Plot (b) plot_projectiles(axs[1], velocities_b, angles_b, colors) axs[1].set_title(\"(b) Projectile motion with 50 m/s at different angles\") plt.tight_layout() plt.show()","title":"Differential Equations of Bullet Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#my-colab","text":"visit website","title":"My Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum exhibits complex dynamics due to the interplay of damping, restoring forces, and external periodic forcing. Understanding this system provides insights into resonance, chaos, and quasiperiodic motion, relevant in fields such as energy harvesting, climate systems, and mechanical vibrations. Theoretical Foundation The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles, we approximate \\[ \\sin(\\theta) \\approx \\theta \\] , reducing the equation to a linear form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The resonance condition occurs when \\[ \\omega \\approx \\omega_0 \\] , leading to maximum amplitude. Numerical Simulation We solve the nonlinear equation numerically using the Runge-Kutta method. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() Analysis of Dynamics Effects of Parameters: Increasing $$ \\gamma $$ leads to faster damping. - Higher $$ A $$ induces chaotic behavior at certain frequencies. When $$ \\omega \\approx \\omega_0 $$ , resonance occurs. - Chaos and Transitions: - A phase portrait can illustrate chaotic behavior. - Poincar\u00e9 sections help identify quasiperiodic or chaotic states. Practical Applications Energy Harvesting: Used in piezoelectric devices. Engineering: Suspension bridges under periodic loads. Biomechanics: Modeling human gait oscillations. Conclusion This study demonstrates the transition from simple periodic motion to chaos. Future extensions can include nonlinear damping or stochastic driving forces. Graphs for 5 States of Pendulum (Python Codes) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Ortak parametreler g = 9.81 # Yer\u00e7ekimi l = 1.0 # Uzunluk gamma = 0.1 # S\u00f6n\u00fcm katsay\u0131s\u0131 A1 = 0.5 # Zorlay\u0131c\u0131 kuvvet (Senaryo 1) A2 = 1.2 # Zorlay\u0131c\u0131 kuvvet (Senaryo 2) w1 = 2.0 # Frekans 1 w2 = 3.5 # Frekans 2 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # Ba\u015flang\u0131\u00e7 a\u00e7\u0131s\u0131 ve h\u0131z\u0131 # Genel \u00e7\u00f6z\u00fcm fonksiyonu def solve_pendulum(func, label): sol = solve_ivp(func, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=label) # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] # T\u00fcm grafikleri \u00e7iz plt.figure(figsize=(14, 8)) solve_pendulum(simple_pendulum, \"1. Simple Pendulum\") solve_pendulum(damped_pendulum, \"2. Damped Pendulum\") solve_pendulum(forced_pendulum, \"3. Forced Pendulum\") solve_pendulum(forced_damped_1, \"4. Forced Damped - Scenario 1\") solve_pendulum(forced_damped_2, \"5. Forced Damped - Scenario 2\") plt.title(\"Pendulum Scenarios\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Phase Diagrams for Pendulum Scenarios (Python Code) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\") visit website","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum exhibits complex dynamics due to the interplay of damping, restoring forces, and external periodic forcing. Understanding this system provides insights into resonance, chaos, and quasiperiodic motion, relevant in fields such as energy harvesting, climate systems, and mechanical vibrations.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The equation of motion for a forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] For small angles, we approximate \\[ \\sin(\\theta) \\approx \\theta \\] , reducing the equation to a linear form: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The resonance condition occurs when \\[ \\omega \\approx \\omega_0 \\] , leading to maximum amplitude.","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation","text":"We solve the nonlinear equation numerically using the Runge-Kutta method. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equations def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Forcing amplitude omega = 2.0 # Forcing frequency # Initial conditions and time span t_span = (0, 50) y0 = [0.2, 0] # Initial angle and angular velocity t_eval = np.linspace(0, 50, 1000) # Solve the ODE sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega)) # Plot results plt.figure(figsize=(10,5)) plt.plot(sol.t, sol.y[0], label=\"Theta (angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Angle (radians)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"Effects of Parameters: Increasing $$ \\gamma $$ leads to faster damping. - Higher $$ A $$ induces chaotic behavior at certain frequencies. When $$ \\omega \\approx \\omega_0 $$ , resonance occurs. - Chaos and Transitions: - A phase portrait can illustrate chaotic behavior. - Poincar\u00e9 sections help identify quasiperiodic or chaotic states.","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting: Used in piezoelectric devices. Engineering: Suspension bridges under periodic loads. Biomechanics: Modeling human gait oscillations.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This study demonstrates the transition from simple periodic motion to chaos. Future extensions can include nonlinear damping or stochastic driving forces.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphs-for-5-states-of-pendulum-python-codes","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Ortak parametreler g = 9.81 # Yer\u00e7ekimi l = 1.0 # Uzunluk gamma = 0.1 # S\u00f6n\u00fcm katsay\u0131s\u0131 A1 = 0.5 # Zorlay\u0131c\u0131 kuvvet (Senaryo 1) A2 = 1.2 # Zorlay\u0131c\u0131 kuvvet (Senaryo 2) w1 = 2.0 # Frekans 1 w2 = 3.5 # Frekans 2 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # Ba\u015flang\u0131\u00e7 a\u00e7\u0131s\u0131 ve h\u0131z\u0131 # Genel \u00e7\u00f6z\u00fcm fonksiyonu def solve_pendulum(func, label): sol = solve_ivp(func, t_span, theta0, t_eval=t_eval) plt.plot(sol.t, sol.y[0], label=label) # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] # T\u00fcm grafikleri \u00e7iz plt.figure(figsize=(14, 8)) solve_pendulum(simple_pendulum, \"1. Simple Pendulum\") solve_pendulum(damped_pendulum, \"2. Damped Pendulum\") solve_pendulum(forced_pendulum, \"3. Forced Pendulum\") solve_pendulum(forced_damped_1, \"4. Forced Damped - Scenario 1\") solve_pendulum(forced_damped_2, \"5. Forced Damped - Scenario 2\") plt.title(\"Pendulum Scenarios\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle \u03b8 (rad)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Graphs for 5 States of Pendulum (Python Codes)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-for-pendulum-scenarios-python-code","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Common parameters g = 9.81 l = 1.0 gamma = 0.1 A1 = 0.5 A2 = 1.2 w1 = 2.0 w2 = 3.5 t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) theta0 = [np.pi / 4, 0] # initial [theta, omega] # Phase plot function def phase_plot(system_func, title): sol = solve_ivp(system_func, t_span, theta0, t_eval=t_eval) theta = sol.y[0] omega = sol.y[1] plt.figure(figsize=(6, 5)) plt.plot(theta, omega, label=title) plt.title(title + \" - Phase Diagram\") plt.xlabel(\"Angle \u03b8 (rad)\") plt.ylabel(\"Angular Velocity \u03c9 (rad/s)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() # 1. Simple Pendulum def simple_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0])] phase_plot(simple_pendulum, \"1. Simple Pendulum\") # 2. Damped Pendulum def damped_pendulum(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0])] phase_plot(damped_pendulum, \"2. Damped Pendulum\") # 3. Forced Pendulum def forced_pendulum(t, y): return [y[1], - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_pendulum, \"3. Forced Pendulum\") # 4. Forced Damped Pendulum - Scenario 1 def forced_damped_1(t, y): return [y[1], -gamma * y[1] - (g / l) * np.sin(y[0]) + A1 * np.cos(w1 * t)] phase_plot(forced_damped_1, \"4. Forced Damped - Scenario 1\") # 5. Forced Damped Pendulum - Scenario 2 def forced_damped_2(t, y): return [y[1], -0.05 * y[1] - (g / l) * np.sin(y[0]) + A2 * np.cos(w2 * t)] phase_plot(forced_damped_2, \"5. Forced Damped - Scenario 2\") visit website","title":"Phase Diagrams for Pendulum Scenarios (Python Code)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 # Orbital Period and Orbital Radius Motivation Kepler's Third Law reveals a powerful and elegant relationship between the time a planet takes to complete an orbit (its orbital period) and its average distance from the body it orbits (orbital radius). This relationship helps astronomers estimate distances in the Solar System and beyond, calculate masses of planets and stars, and understand orbital dynamics. Derivation of Kepler's Third Law for Circular Orbits For a body of mass m orbiting a much larger mass M (like a planet around the Sun), the centripetal force is provided by gravity: Gravitational Force = Centripetal Force \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for orbital velocity v : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period T is the time it takes to make one full orbit: \\[ T = \\frac{2\\pi r}{v} = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] This is Kepler's Third Law. Implications in Astronomy Helps determine the mass of celestial bodies. Allows estimation of distances between planets and stars. Provides a method for understanding satellite trajectories. Real-World Examples 1. Moon's Orbit Around Earth import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # m # Calculate orbital period T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Orbital Period of Moon: {T_moon_days:.2f} days\") Orbital Period of Moon: 27.45 days Extension to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits when using the semi-major axis a instead of radius r : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] This version holds true for all elliptical orbits, making the law universally applicable to binary stars, moons, and exoplanets. Conclusion: Kepler's Third Law connects orbital periods and radii through gravity's universal law. Whether examining artificial satellites or exoplanets, this principle guides modern astronomy and space science. 2. Planets in the Solar System import numpy as np import matplotlib.pyplot as plt # Orbital radius in AU and orbital period in years for selected planets radii_au = np.array([0.39, 0.72, 1.0, 1.52]) # Mercury to Mars periods_years = np.array([0.24, 0.61, 1.0, 1.88]) planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] # Calculate r^3 and T^2 r_cubed = radii_au**3 T_squared = periods_years**2 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r\"$T^2$ vs $r^3$\") # Annotate each point with the planet name for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.02, T_squared[i] * 0.98, name, fontsize=10) plt.xlabel(r\"Orbital Radius$^3$ (AU$^3$)\", fontsize=12) plt.ylabel(r\"Orbital Period$^2$ (Years$^2$)\", fontsize=12) plt.title(\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants r = 384400e3 # Radius of Moon's orbit in meters T = 27.3 * 24 * 3600 # Period in seconds # Time values n_frames = 200 time_vals = np.linspace(0, T, n_frames) # Orbital position calculations x_vals = r * np.cos(2 * np.pi * time_vals / T) y_vals = r * np.sin(2 * np.pi * time_vals / T) # Set up the plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.plot(0, 0, 'yo', markersize=12, label='Earth') orbit_path, = ax.plot([], [], 'k--', alpha=0.5) moon, = ax.plot([], [], 'bo', label='Moon') def init(): orbit_path.set_data(x_vals, y_vals) moon.set_data([], []) return orbit_path, moon def update(frame): moon.set_data(x_vals[frame], y_vals[frame]) return moon, ani = FuncAnimation(fig, update, frames=n_frames, init_func=init, blit=True) plt.title(\"Circular Orbit: Moon Around Earth\") plt.legend() plt.show() Simulation of Circular Orbits # Linear regression (for illustrative best-fit) from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label=\"Observed\") plt.plot(r_cubed, fit_line, '-', label=f\"Best Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel(r\"Orbital Radius$^3$ (AU$^3$)\") plt.ylabel(r\"Orbital Period$^2$ (Years$^2$)\") plt.title(\"Kepler's Third Law Linear Fit\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() visit website","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"# Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law reveals a powerful and elegant relationship between the time a planet takes to complete an orbit (its orbital period) and its average distance from the body it orbits (orbital radius). This relationship helps astronomers estimate distances in the Solar System and beyond, calculate masses of planets and stars, and understand orbital dynamics.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law-for-circular-orbits","text":"For a body of mass m orbiting a much larger mass M (like a planet around the Sun), the centripetal force is provided by gravity: Gravitational Force = Centripetal Force \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Solving for orbital velocity v : \\[ v = \\sqrt{\\frac{GM}{r}} \\] The orbital period T is the time it takes to make one full orbit: \\[ T = \\frac{2\\pi r}{v} = \\frac{2\\pi r}{\\sqrt{\\frac{GM}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Squaring both sides: \\[ T^2 = \\frac{4\\pi^2}{GM} r^3 \\] Thus: \\[ T^2 \\propto r^3 \\] This is Kepler's Third Law.","title":"Derivation of Kepler's Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Helps determine the mass of celestial bodies. Allows estimation of distances between planets and stars. Provides a method for understanding satellite trajectories.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-moons-orbit-around-earth","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M_earth = 5.972e24 # kg r_moon = 384400e3 # m # Calculate orbital period T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) print(f\"Orbital Period of Moon: {T_moon_days:.2f} days\") Orbital Period of Moon: 27.45 days","title":"1. Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits when using the semi-major axis a instead of radius r : \\[ T^2 = \\frac{4\\pi^2}{GM} a^3 \\] This version holds true for all elliptical orbits, making the law universally applicable to binary stars, moons, and exoplanets. Conclusion: Kepler's Third Law connects orbital periods and radii through gravity's universal law. Whether examining artificial satellites or exoplanets, this principle guides modern astronomy and space science.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"import numpy as np import matplotlib.pyplot as plt # Orbital radius in AU and orbital period in years for selected planets radii_au = np.array([0.39, 0.72, 1.0, 1.52]) # Mercury to Mars periods_years = np.array([0.24, 0.61, 1.0, 1.88]) planet_names = ['Mercury', 'Venus', 'Earth', 'Mars'] # Calculate r^3 and T^2 r_cubed = radii_au**3 T_squared = periods_years**2 # Plotting plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o-', color='royalblue', label=r\"$T^2$ vs $r^3$\") # Annotate each point with the planet name for i, name in enumerate(planet_names): plt.text(r_cubed[i] * 1.02, T_squared[i] * 0.98, name, fontsize=10) plt.xlabel(r\"Orbital Radius$^3$ (AU$^3$)\", fontsize=12) plt.ylabel(r\"Orbital Period$^2$ (Years$^2$)\", fontsize=12) plt.title(\"Kepler's Third Law: $T^2 \\propto r^3$\", fontsize=14) plt.grid(True) plt.legend() plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants r = 384400e3 # Radius of Moon's orbit in meters T = 27.3 * 24 * 3600 # Period in seconds # Time values n_frames = 200 time_vals = np.linspace(0, T, n_frames) # Orbital position calculations x_vals = r * np.cos(2 * np.pi * time_vals / T) y_vals = r * np.sin(2 * np.pi * time_vals / T) # Set up the plot fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-1.2*r, 1.2*r) ax.set_ylim(-1.2*r, 1.2*r) ax.set_aspect('equal') ax.plot(0, 0, 'yo', markersize=12, label='Earth') orbit_path, = ax.plot([], [], 'k--', alpha=0.5) moon, = ax.plot([], [], 'bo', label='Moon') def init(): orbit_path.set_data(x_vals, y_vals) moon.set_data([], []) return orbit_path, moon def update(frame): moon.set_data(x_vals[frame], y_vals[frame]) return moon, ani = FuncAnimation(fig, update, frames=n_frames, init_func=init, blit=True) plt.title(\"Circular Orbit: Moon Around Earth\") plt.legend() plt.show()","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#simulation-of-circular-orbits","text":"# Linear regression (for illustrative best-fit) from scipy.stats import linregress slope, intercept, r_value, _, _ = linregress(r_cubed, T_squared) fit_line = slope * r_cubed + intercept plt.figure(figsize=(8, 6)) plt.plot(r_cubed, T_squared, 'o', label=\"Observed\") plt.plot(r_cubed, fit_line, '-', label=f\"Best Fit: $T^2 = {slope:.2f}r^3 + {intercept:.2f}$\") plt.xlabel(r\"Orbital Radius$^3$ (AU$^3$)\") plt.ylabel(r\"Orbital Period$^2$ (Years$^2$)\") plt.title(\"Kepler's Third Law Linear Fit\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() visit website","title":"Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 # Escape Velocities and Cosmic Velocities Motivation Understanding the concept of escape velocity is essential in astrophysics and space engineering. It defines the minimum speed an object must reach to break free from a celestial body's gravitational influence. The three cosmic velocities categorize different thresholds: reaching orbit (first), escaping the planet (second), and escaping the entire star system (third). These concepts guide space missions, from launching satellites to interstellar exploration. Definitions First Cosmic Velocity (v\u2081) : Minimum velocity to maintain a stable circular orbit around a body. $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (v\u2082) : Minimum velocity to escape the gravitational pull of a body (escape velocity). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (v\u2083) : Minimum velocity to escape the gravitational influence of the entire solar system from Earth's surface, assuming the spacecraft is not assisted by other celestial bodies. $$ v_3 \\approx 16.7 \\text{ km/s (from Earth)} $$ Mathematical Derivation Starting with energy conservation: Total energy at escape = 0: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] For orbital velocity: \\[ F_{gravity} = F_{centripetal} \\Rightarrow \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} \\] Python Calculations and Visualizations import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Define planetary data (mass in kg, radius in meters) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3}, } # Calculate and store velocities velocities = {} for body, data in bodies.items(): M = data['mass'] r = data['radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2) * v1 v3 = 16.7e3 if body == 'Earth' else np.nan # third cosmic velocity approx from Earth velocities[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Display for body in velocities: v = velocities[body] print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {v['v1'] / 1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v['v2'] / 1e3:.2f} km/s\") if not np.isnan(v['v3']): print(f\" Third Cosmic Velocity (v3): {v['v3'] / 1e3:.2f} km/s\") print() Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Third Cosmic Velocity (v3): 16.70 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.07 km/s Second Cosmic Velocity (v2): 59.49 km/s Bar Chart of Velocities # Bar chart labels = list(bodies.keys()) x = np.arange(len(labels)) width = 0.25 v1_vals = [velocities[body]['v1'] / 1e3 for body in labels] v2_vals = [velocities[body]['v2'] / 1e3 for body in labels] v3_vals = [velocities[body]['v3'] / 1e3 if not np.isnan(velocities[body]['v3']) else 0 for body in labels] fig, ax = plt.subplots(figsize=(10, 6)) rects1 = ax.bar(x - width, v1_vals, width, label='v\u2081 (Orbit)') rects2 = ax.bar(x, v2_vals, width, label='v\u2082 (Escape)') rects3 = ax.bar(x + width, v3_vals, width, label='v\u2083 (Solar Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() X-axis: Planet names (Earth, Mars, Jupiter) Y-axis: Velocities in km/s Three bars for each body: v\u2081 (Orbit): First cosmic velocity (to orbit the planet) v\u2082 (Escape): Second cosmic velocity (to escape the planet\u2019s gravity) v\u2083 (Solar Escape): Third cosmic velocity (escape the Solar System from that planet) \u2013 only Earth has a defined value For example: Earth will show 7.91 (v\u2081), 11.18 (v\u2082), 16.70 (v\u2083) Mars will show 3.55 (v\u2081), 5.02 (v\u2082), 0 (v\u2083 bar won't be visible) Jupiter will show 42.07 (v\u2081), 59.49 (v\u2082), 0 (v\u2083 bar won't be visible) Importance in Space Exploration First Cosmic Velocity : Required for satellites to maintain orbit (e.g., ISS). Second Cosmic Velocity : Determines launch speed for interplanetary missions (e.g., Mars rovers). Third Cosmic Velocity : Relevant for missions aiming to leave the Solar System (e.g., Voyager 1). These thresholds are crucial for mission planning, rocket fuel estimation, and interplanetary navigation. Conclusion Cosmic velocities define the fundamental speed requirements for space travel. Understanding and calculating them is vital for launching and navigating spacecraft, paving the way for deeper space exploration. import matplotlib.pyplot as plt import numpy as np # Velocities in km/s (from previous calculations) velocities = { 'Earth': {'v1': 7.91, 'v2': 11.2, 'v3': 16.7}, 'Mars': {'v1': 3.55, 'v2': 5.03, 'v3': 0}, # v3 not defined 'Jupiter': {'v1': 42.0, 'v2': 59.5, 'v3': 0}, # v3 not defined } labels = list(velocities.keys()) x = np.arange(len(labels)) width = 0.25 v1_vals = [velocities[body]['v1'] for body in labels] v2_vals = [velocities[body]['v2'] for body in labels] v3_vals = [velocities[body]['v3'] for body in labels] fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_vals, width, label='v\u2081 (Orbit)', color='skyblue') ax.bar(x, v2_vals, width, label='v\u2082 (Escape)', color='salmon') ax.bar(x + width, v3_vals, width, label='v\u2083 (Solar Escape)', color='gold') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() G = 6.67430e-11 mass_earth = 5.972e24 # kg radii = np.linspace(1e6, 1e8, 500) v_escape = np.sqrt(2 * G * mass_earth / radii) / 1e3 # km/s plt.figure(figsize=(8, 5)) plt.plot(radii / 1e6, v_escape, color='purple') plt.xlabel('Radius from Center (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Radius from Earth-like Planet') plt.grid(True) plt.tight_layout() plt.show() import matplotlib.patches as patches fig, ax = plt.subplots(figsize=(8, 3)) ax.arrow(0, 0.5, 2, 0, head_width=0.2, head_length=0.3, fc='blue', ec='blue') ax.arrow(0, 1.5, 3, 0, head_width=0.2, head_length=0.3, fc='red', ec='red') ax.arrow(0, 2.5, 4.5, 0, head_width=0.2, head_length=0.3, fc='green', ec='green') ax.text(2.1, 0.4, 'v\u2081 (Orbit)', color='blue') ax.text(3.2, 1.4, 'v\u2082 (Escape)', color='red') ax.text(4.7, 2.4, 'v\u2083 (Solar Escape)', color='green') ax.set_xlim(0, 6) ax.set_ylim(0, 3.5) ax.axis('off') ax.set_title('Conceptual Diagram of Cosmic Velocities') plt.tight_layout() plt.show() visit website","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"# Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding the concept of escape velocity is essential in astrophysics and space engineering. It defines the minimum speed an object must reach to break free from a celestial body's gravitational influence. The three cosmic velocities categorize different thresholds: reaching orbit (first), escaping the planet (second), and escaping the entire star system (third). These concepts guide space missions, from launching satellites to interstellar exploration.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (v\u2081) : Minimum velocity to maintain a stable circular orbit around a body. $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity (v\u2082) : Minimum velocity to escape the gravitational pull of a body (escape velocity). $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity (v\u2083) : Minimum velocity to escape the gravitational influence of the entire solar system from Earth's surface, assuming the spacecraft is not assisted by other celestial bodies. $$ v_3 \\approx 16.7 \\text{ km/s (from Earth)} $$","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation","text":"Starting with energy conservation: Total energy at escape = 0: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{r} = 0 \\Rightarrow v = \\sqrt{\\frac{2GM}{r}} \\] For orbital velocity: \\[ F_{gravity} = F_{centripetal} \\Rightarrow \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\Rightarrow v = \\sqrt{\\frac{GM}{r}} \\]","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-calculations-and-visualizations","text":"import numpy as np import matplotlib.pyplot as plt # Gravitational constant G = 6.67430e-11 # m^3 kg^-1 s^-2 # Define planetary data (mass in kg, radius in meters) bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3}, } # Calculate and store velocities velocities = {} for body, data in bodies.items(): M = data['mass'] r = data['radius'] v1 = np.sqrt(G * M / r) v2 = np.sqrt(2) * v1 v3 = 16.7e3 if body == 'Earth' else np.nan # third cosmic velocity approx from Earth velocities[body] = {'v1': v1, 'v2': v2, 'v3': v3} # Display for body in velocities: v = velocities[body] print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {v['v1'] / 1e3:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {v['v2'] / 1e3:.2f} km/s\") if not np.isnan(v['v3']): print(f\" Third Cosmic Velocity (v3): {v['v3'] / 1e3:.2f} km/s\") print() Earth: First Cosmic Velocity (v1): 7.91 km/s Second Cosmic Velocity (v2): 11.18 km/s Third Cosmic Velocity (v3): 16.70 km/s Mars: First Cosmic Velocity (v1): 3.55 km/s Second Cosmic Velocity (v2): 5.02 km/s Jupiter: First Cosmic Velocity (v1): 42.07 km/s Second Cosmic Velocity (v2): 59.49 km/s","title":"Python Calculations and Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#bar-chart-of-velocities","text":"# Bar chart labels = list(bodies.keys()) x = np.arange(len(labels)) width = 0.25 v1_vals = [velocities[body]['v1'] / 1e3 for body in labels] v2_vals = [velocities[body]['v2'] / 1e3 for body in labels] v3_vals = [velocities[body]['v3'] / 1e3 if not np.isnan(velocities[body]['v3']) else 0 for body in labels] fig, ax = plt.subplots(figsize=(10, 6)) rects1 = ax.bar(x - width, v1_vals, width, label='v\u2081 (Orbit)') rects2 = ax.bar(x, v2_vals, width, label='v\u2082 (Escape)') rects3 = ax.bar(x + width, v3_vals, width, label='v\u2083 (Solar Escape)') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Celestial Bodies') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() X-axis: Planet names (Earth, Mars, Jupiter) Y-axis: Velocities in km/s Three bars for each body: v\u2081 (Orbit): First cosmic velocity (to orbit the planet) v\u2082 (Escape): Second cosmic velocity (to escape the planet\u2019s gravity) v\u2083 (Solar Escape): Third cosmic velocity (escape the Solar System from that planet) \u2013 only Earth has a defined value For example: Earth will show 7.91 (v\u2081), 11.18 (v\u2082), 16.70 (v\u2083) Mars will show 3.55 (v\u2081), 5.02 (v\u2082), 0 (v\u2083 bar won't be visible) Jupiter will show 42.07 (v\u2081), 59.49 (v\u2082), 0 (v\u2083 bar won't be visible)","title":"Bar Chart of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Required for satellites to maintain orbit (e.g., ISS). Second Cosmic Velocity : Determines launch speed for interplanetary missions (e.g., Mars rovers). Third Cosmic Velocity : Relevant for missions aiming to leave the Solar System (e.g., Voyager 1). These thresholds are crucial for mission planning, rocket fuel estimation, and interplanetary navigation.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Cosmic velocities define the fundamental speed requirements for space travel. Understanding and calculating them is vital for launching and navigating spacecraft, paving the way for deeper space exploration. import matplotlib.pyplot as plt import numpy as np # Velocities in km/s (from previous calculations) velocities = { 'Earth': {'v1': 7.91, 'v2': 11.2, 'v3': 16.7}, 'Mars': {'v1': 3.55, 'v2': 5.03, 'v3': 0}, # v3 not defined 'Jupiter': {'v1': 42.0, 'v2': 59.5, 'v3': 0}, # v3 not defined } labels = list(velocities.keys()) x = np.arange(len(labels)) width = 0.25 v1_vals = [velocities[body]['v1'] for body in labels] v2_vals = [velocities[body]['v2'] for body in labels] v3_vals = [velocities[body]['v3'] for body in labels] fig, ax = plt.subplots(figsize=(10, 6)) ax.bar(x - width, v1_vals, width, label='v\u2081 (Orbit)', color='skyblue') ax.bar(x, v2_vals, width, label='v\u2082 (Escape)', color='salmon') ax.bar(x + width, v3_vals, width, label='v\u2083 (Solar Escape)', color='gold') ax.set_ylabel('Velocity (km/s)') ax.set_title('Cosmic Velocities for Earth, Mars, Jupiter') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True, linestyle='--', alpha=0.6) plt.tight_layout() plt.show() G = 6.67430e-11 mass_earth = 5.972e24 # kg radii = np.linspace(1e6, 1e8, 500) v_escape = np.sqrt(2 * G * mass_earth / radii) / 1e3 # km/s plt.figure(figsize=(8, 5)) plt.plot(radii / 1e6, v_escape, color='purple') plt.xlabel('Radius from Center (10\u2076 m)') plt.ylabel('Escape Velocity (km/s)') plt.title('Escape Velocity vs Radius from Earth-like Planet') plt.grid(True) plt.tight_layout() plt.show() import matplotlib.patches as patches fig, ax = plt.subplots(figsize=(8, 3)) ax.arrow(0, 0.5, 2, 0, head_width=0.2, head_length=0.3, fc='blue', ec='blue') ax.arrow(0, 1.5, 3, 0, head_width=0.2, head_length=0.3, fc='red', ec='red') ax.arrow(0, 2.5, 4.5, 0, head_width=0.2, head_length=0.3, fc='green', ec='green') ax.text(2.1, 0.4, 'v\u2081 (Orbit)', color='blue') ax.text(3.2, 1.4, 'v\u2082 (Escape)', color='red') ax.text(4.7, 2.4, 'v\u2083 (Solar Escape)', color='green') ax.set_xlim(0, 6) ax.set_ylim(0, 3.5) ax.axis('off') ax.set_title('Conceptual Diagram of Cosmic Velocities') plt.tight_layout() plt.show() visit website","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 # Trajectories of a Freely Released Payload Near Earth Motivation The trajectory of an object released from a moving rocket depends on its initial velocity and the gravitational influence of Earth. By analyzing these trajectories, we can understand orbital insertion, reentry paths, or escape scenarios. This knowledge is essential in space mission planning, satellite deployment, and reentry vehicle design. Physics Background Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\Rightarrow a = \\frac{GM}{r^2} \\] This acceleration acts towards the center of Earth. Types of Trajectories Circular Orbit : Object moves with constant speed in a circular path. Elliptical Orbit : Object is bound to Earth but not at a constant distance. Parabolic Escape : Minimum speed to escape Earth's gravity. Hyperbolic Escape : Object escapes Earth with excess velocity. Suborbital Trajectory : Falls back to Earth before completing an orbit. Initial Conditions and Solver # Choose an altitude and initial velocity (vary this to simulate different cases) altitude = 300e3 # 300 km r0 = R_earth + altitude v_circular = np.sqrt(mu / r0) # Circular orbital speed # Modify initial velocity to simulate different trajectories initial_conditions = { 'suborbital': [0, 0.7 * v_circular], 'circular': [0, v_circular], 'elliptical': [0, 1.1 * v_circular], 'escape': [0, np.sqrt(2) * v_circular], } fig, ax = plt.subplots(figsize=(8, 8)) for label, vy0 in initial_conditions.items(): y0 = [r0, 0, 0, vy0] # x, vx, y, vy sol = solve_ivp(equations, [0, 10000], y0, t_eval=np.linspace(0, 10000, 5000)) x = sol.y[0] y = sol.y[2] ax.plot(x / 1e3, y / 1e3, label=label) # Earth earth = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3) ax.add_patch(earth) ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_title('Payload Trajectories near Earth') ax.set_aspect('equal') ax.legend() plt.grid(True) plt.tight_layout() plt.show() Applications in Space Missions Orbital Insertion : Matching circular or elliptical orbits for satellites. Escape Trajectory : Interplanetary missions (e.g., to Mars). Reentry Design : Predicting where a returning capsule will land. Conclusion By changing the initial velocity of a payload, we observe distinct paths that help classify motion near Earth. Simulating these paths enhances our understanding of celestial mechanics and supports mission-critical decisions in aerospace engineering. radii = np.linspace(R_earth, R_earth + 2e6, 500) v_orbit = np.sqrt(mu / radii) / 1e3 # km/s v_escape = np.sqrt(2 * mu / radii) / 1e3 # km/s plt.figure(figsize=(8, 5)) plt.plot((radii - R_earth) / 1e3, v_orbit, label='Orbital Velocity') plt.plot((radii - R_earth) / 1e3, v_escape, label='Escape Velocity') plt.xlabel('Altitude (km)') plt.ylabel('Velocity (km/s)') plt.title('Velocity vs Altitude Near Earth') plt.legend() plt.grid(True) plt.tight_layout() plt.show() x = np.linspace(-2e7, 2e7, 40) y = np.linspace(-2e7, 2e7, 40) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) ax = -mu * X / R**3 ay = -mu * Y / R**3 plt.figure(figsize=(7, 7)) plt.streamplot(X/1e6, Y/1e6, ax, ay, color=np.sqrt(ax**2 + ay**2), cmap='plasma') earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.xlabel('X (10\u2076 m)') plt.ylabel('Y (10\u2076 m)') plt.title('Gravitational Vector Field Around Earth') plt.grid(True) plt.axis('equal') plt.show() visit website","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"# Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"The trajectory of an object released from a moving rocket depends on its initial velocity and the gravitational influence of Earth. By analyzing these trajectories, we can understand orbital insertion, reentry paths, or escape scenarios. This knowledge is essential in space mission planning, satellite deployment, and reentry vehicle design.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#physics-background","text":"","title":"Physics Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"\\[ F = \\frac{GMm}{r^2} \\Rightarrow a = \\frac{GM}{r^2} \\] This acceleration acts towards the center of Earth.","title":"Newton's Law of Gravitation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Circular Orbit : Object moves with constant speed in a circular path. Elliptical Orbit : Object is bound to Earth but not at a constant distance. Parabolic Escape : Minimum speed to escape Earth's gravity. Hyperbolic Escape : Object escapes Earth with excess velocity. Suborbital Trajectory : Falls back to Earth before completing an orbit.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-and-solver","text":"# Choose an altitude and initial velocity (vary this to simulate different cases) altitude = 300e3 # 300 km r0 = R_earth + altitude v_circular = np.sqrt(mu / r0) # Circular orbital speed # Modify initial velocity to simulate different trajectories initial_conditions = { 'suborbital': [0, 0.7 * v_circular], 'circular': [0, v_circular], 'elliptical': [0, 1.1 * v_circular], 'escape': [0, np.sqrt(2) * v_circular], } fig, ax = plt.subplots(figsize=(8, 8)) for label, vy0 in initial_conditions.items(): y0 = [r0, 0, 0, vy0] # x, vx, y, vy sol = solve_ivp(equations, [0, 10000], y0, t_eval=np.linspace(0, 10000, 5000)) x = sol.y[0] y = sol.y[2] ax.plot(x / 1e3, y / 1e3, label=label) # Earth earth = plt.Circle((0, 0), R_earth / 1e3, color='blue', alpha=0.3) ax.add_patch(earth) ax.set_xlabel('x (km)') ax.set_ylabel('y (km)') ax.set_title('Payload Trajectories near Earth') ax.set_aspect('equal') ax.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Initial Conditions and Solver"},{"location":"1%20Physics/2%20Gravity/Problem_3/#applications-in-space-missions","text":"Orbital Insertion : Matching circular or elliptical orbits for satellites. Escape Trajectory : Interplanetary missions (e.g., to Mars). Reentry Design : Predicting where a returning capsule will land.","title":"Applications in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By changing the initial velocity of a payload, we observe distinct paths that help classify motion near Earth. Simulating these paths enhances our understanding of celestial mechanics and supports mission-critical decisions in aerospace engineering. radii = np.linspace(R_earth, R_earth + 2e6, 500) v_orbit = np.sqrt(mu / radii) / 1e3 # km/s v_escape = np.sqrt(2 * mu / radii) / 1e3 # km/s plt.figure(figsize=(8, 5)) plt.plot((radii - R_earth) / 1e3, v_orbit, label='Orbital Velocity') plt.plot((radii - R_earth) / 1e3, v_escape, label='Escape Velocity') plt.xlabel('Altitude (km)') plt.ylabel('Velocity (km/s)') plt.title('Velocity vs Altitude Near Earth') plt.legend() plt.grid(True) plt.tight_layout() plt.show() x = np.linspace(-2e7, 2e7, 40) y = np.linspace(-2e7, 2e7, 40) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) ax = -mu * X / R**3 ay = -mu * Y / R**3 plt.figure(figsize=(7, 7)) plt.streamplot(X/1e6, Y/1e6, ax, ay, color=np.sqrt(ax**2 + ay**2), cmap='plasma') earth = plt.Circle((0, 0), R_earth / 1e6, color='blue', alpha=0.3) plt.gca().add_patch(earth) plt.xlabel('X (10\u2076 m)') plt.ylabel('Y (10\u2076 m)') plt.title('Gravitational Vector Field Around Earth') plt.grid(True) plt.axis('equal') plt.show() visit website","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 # Interference Patterns on a Water Surface Motivation Interference on a water surface provides a beautiful, tangible example of how waves interact. By studying these patterns from coherent point sources arranged in a regular polygon, we can observe and analyze wave superposition, constructive interference (bright spots), and destructive interference (dark spots). Assumptions and Parameters All sources emit circular waves. Same amplitude \\[ A \\] , wavelength $$ \\lambda $$ , and frequency $$ f $$ . - The phase is constant across all sources. Imports and Configuration import numpy as np import matplotlib.pyplot as plt Observations Constructive Interference : Regions where waves add (bright colors). Destructive Interference : Regions where waves cancel (dark colors). Symmetry : The pattern reflects the symmetry of the polygon. Try changing N to 3 (triangle), 4 (square), or more to explore different polygon arrangements. Conclusion This simulation shows how coherent sources produce rich interference patterns. The configuration of the sources determines the spatial frequency and symmetry of the interference. Such analyses are useful in acoustics, optics, and wave physics in general. import numpy as np import matplotlib.pyplot as plt # Dalga parametreleri A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 # Grid tan\u0131m\u0131 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Kaynaklar\u0131n yer alaca\u011f\u0131 dairenin yar\u0131\u00e7ap\u0131 radius = 2.0 # Kaynaklar\u0131 \u00fcret def generate_sources(N): if N == 1: return [(0, 0)] # Tek kaynak merkezde elif N == 2: return [(-radius / 2, 0), (radius / 2, 0)] # \u0130ki kaynak yatay eksende else: raise ValueError(\"Bu s\u00fcr\u00fcm sadece N=1 ve N=2 i\u00e7indir.\") # Giri\u015fim desenini \u00e7iz def plot_pattern(N): sources = generate_sources(N) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') # Kaynaklar\u0131 siyah noktalarla \u00e7iz for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N} Noktal\u0131 Kaynak Giri\u015fimi') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Dalga Yer De\u011fi\u015fimi') plt.grid(True) plt.show() # Yaln\u0131zca N = 1 ve N = 2 durumlar\u0131 i\u00e7in \u00e7izim for N in [1, 2]: plot_pattern(N) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) radius = 2.0 def generate_polygon_sources(N, radius): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] def plot_pattern(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N}-Point Source Interference') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Triangle, Square, Pentagon for N in [3, 4, 5]: plot_pattern(N) from mpl_toolkits.mplot3d import Axes3D def plot_3d_surface(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface ({N} Sources)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.show() # Show 3D pattern for pentagon plot_3d_surface(5) visit website","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"# Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference on a water surface provides a beautiful, tangible example of how waves interact. By studying these patterns from coherent point sources arranged in a regular polygon, we can observe and analyze wave superposition, constructive interference (bright spots), and destructive interference (dark spots).","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions-and-parameters","text":"All sources emit circular waves. Same amplitude \\[ A \\] , wavelength $$ \\lambda $$ , and frequency $$ f $$ . - The phase is constant across all sources.","title":"Assumptions and Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#imports-and-configuration","text":"import numpy as np import matplotlib.pyplot as plt","title":"Imports and Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Constructive Interference : Regions where waves add (bright colors). Destructive Interference : Regions where waves cancel (dark colors). Symmetry : The pattern reflects the symmetry of the polygon. Try changing N to 3 (triangle), 4 (square), or more to explore different polygon arrangements.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation shows how coherent sources produce rich interference patterns. The configuration of the sources determines the spatial frequency and symmetry of the interference. Such analyses are useful in acoustics, optics, and wave physics in general. import numpy as np import matplotlib.pyplot as plt # Dalga parametreleri A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 # Grid tan\u0131m\u0131 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Kaynaklar\u0131n yer alaca\u011f\u0131 dairenin yar\u0131\u00e7ap\u0131 radius = 2.0 # Kaynaklar\u0131 \u00fcret def generate_sources(N): if N == 1: return [(0, 0)] # Tek kaynak merkezde elif N == 2: return [(-radius / 2, 0), (radius / 2, 0)] # \u0130ki kaynak yatay eksende else: raise ValueError(\"Bu s\u00fcr\u00fcm sadece N=1 ve N=2 i\u00e7indir.\") # Giri\u015fim desenini \u00e7iz def plot_pattern(N): sources = generate_sources(N) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') # Kaynaklar\u0131 siyah noktalarla \u00e7iz for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N} Noktal\u0131 Kaynak Giri\u015fimi') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Dalga Yer De\u011fi\u015fimi') plt.grid(True) plt.show() # Yaln\u0131zca N = 1 ve N = 2 durumlar\u0131 i\u00e7in \u00e7izim for N in [1, 2]: plot_pattern(N) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) radius = 2.0 def generate_polygon_sources(N, radius): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] def plot_pattern(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N}-Point Source Interference') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Triangle, Square, Pentagon for N in [3, 4, 5]: plot_pattern(N) from mpl_toolkits.mplot3d import Axes3D def plot_3d_surface(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface ({N} Sources)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.show() # Show 3D pattern for pentagon plot_3d_surface(5) visit website","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 # Simulating the Effects of the Lorentz Force Motivation The Lorentz force plays a fundamental role in electromagnetism, governing the motion of charged particles in electric and magnetic fields. Understanding this force is crucial in applications like particle accelerators, mass spectrometers, and plasma confinement systems. Key Equations The Lorentz force equation is: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: $$ q $$ = charge of the particle \\[ \\vec{E} \\] = electric field \\[ \\vec{B} \\] = magnetic field \\[ \\vec{v} \\] = velocity of the particle Imports import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D Lorentz Force Simulation (Euler Method) def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) # Set initial conditions r[0] = r0 v[0] = v0 # Numerical integration for i in range(1, N): a = lorentz_force(q, v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt Simulation Parameters import numpy as np import matplotlib.pyplot as plt # === Particle and Field Parameters === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === r = np.array([0.0, 0.0, 0.0]) # Position (m) v = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) # === Time Setup === dt = 0.01 # Time step (s) T = 20 # Total time (s) N = int(T / dt) # === Data Storage for Trajectory === trajectory = np.zeros((N, 3)) time = np.linspace(0, T, N) # === Simulation Loop === for i in range(N): # Save current position trajectory[i] = r # Lorentz force: F = q(E + v \u00d7 B) force = q * (E + np.cross(v, B)) # Acceleration a = force / m # Euler integration (can upgrade to Runge-Kutta for higher accuracy) v += a * dt r += v * dt # === Plotting the Trajectory in XY Plane === plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Magnetic Field (Circular Motion)') plt.grid(True) plt.axis('equal') plt.legend() plt.show() 3D Trajectory Visualization fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2], label='Particle Trajectory') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title('Charged Particle in Magnetic Field') ax.legend() plt.tight_layout() plt.show() Observations and Physical Insight Circular motion : Occurs when only a magnetic field is present and the initial velocity is perpendicular to the field. Helical motion : Results from a velocity component both parallel and perpendicular to the magnetic field. Drift motion : Emerges when electric and magnetic fields are crossed. Larmor Radius: \\[ r_L = \\frac{mv_\\perp}{qB} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] Extensions Add non-uniform magnetic fields. Include relativistic corrections . Simulate plasma behavior with multiple particles. Conclusion This simulation gives insight into the fundamental behavior of charged particles under electromagnetic influence. Real-world applications span from fusion reactors to space plasma dynamics and particle beam control in accelerators. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # charge m = 1.0 # mass B = np.array([0, 0, 1.0]) # uniform magnetic field E = np.array([0, 0, 0]) # no electric field v0 = np.array([1.0, 0.0, 1.0]) # velocity with component along B r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 T = 20 N = int(T / dt) # Arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Integrate using Euler method for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 3D Plot fig = plt.figure(figsize=(10,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_title('Helical Motion of a Charged Particle') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') plt.show() # Crossed fields: E in x-direction, B in z-direction E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([0.0, 1.0, 0.0]) # initial velocity # Reinitialize r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 2D Plot of Drift plt.figure(figsize=(8,6)) plt.plot(r[:,0], r[:,1]) plt.title('Drift Motion in Crossed Electric and Magnetic Fields') plt.xlabel('X') plt.ylabel('Y') plt.axis('equal') plt.grid(True) plt.show() visit website","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"# Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force plays a fundamental role in electromagnetism, governing the motion of charged particles in electric and magnetic fields. Understanding this force is crucial in applications like particle accelerators, mass spectrometers, and plasma confinement systems.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-equations","text":"The Lorentz force equation is: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: $$ q $$ = charge of the particle \\[ \\vec{E} \\] = electric field \\[ \\vec{B} \\] = magnetic field \\[ \\vec{v} \\] = velocity of the particle","title":"Key Equations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#imports","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D","title":"Imports"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulation-euler-method","text":"def lorentz_force(q, v, E, B): return q * (E + np.cross(v, B)) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) # Set initial conditions r[0] = r0 v[0] = v0 # Numerical integration for i in range(1, N): a = lorentz_force(q, v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt","title":"Lorentz Force Simulation (Euler Method)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-parameters","text":"import numpy as np import matplotlib.pyplot as plt # === Particle and Field Parameters === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === r = np.array([0.0, 0.0, 0.0]) # Position (m) v = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) # === Time Setup === dt = 0.01 # Time step (s) T = 20 # Total time (s) N = int(T / dt) # === Data Storage for Trajectory === trajectory = np.zeros((N, 3)) time = np.linspace(0, T, N) # === Simulation Loop === for i in range(N): # Save current position trajectory[i] = r # Lorentz force: F = q(E + v \u00d7 B) force = q * (E + np.cross(v, B)) # Acceleration a = force / m # Euler integration (can upgrade to Runge-Kutta for higher accuracy) v += a * dt r += v * dt # === Plotting the Trajectory in XY Plane === plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Magnetic Field (Circular Motion)') plt.grid(True) plt.axis('equal') plt.legend() plt.show()","title":"Simulation Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3d-trajectory-visualization","text":"fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2], label='Particle Trajectory') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') ax.set_title('Charged Particle in Magnetic Field') ax.legend() plt.tight_layout() plt.show()","title":"3D Trajectory Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations-and-physical-insight","text":"Circular motion : Occurs when only a magnetic field is present and the initial velocity is perpendicular to the field. Helical motion : Results from a velocity component both parallel and perpendicular to the magnetic field. Drift motion : Emerges when electric and magnetic fields are crossed.","title":"Observations and Physical Insight"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius","text":"\\[ r_L = \\frac{mv_\\perp}{qB} \\]","title":"Larmor Radius:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[ \\omega_c = \\frac{qB}{m} \\]","title":"Cyclotron Frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Add non-uniform magnetic fields. Include relativistic corrections . Simulate plasma behavior with multiple particles.","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This simulation gives insight into the fundamental behavior of charged particles under electromagnetic influence. Real-world applications span from fusion reactors to space plasma dynamics and particle beam control in accelerators. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # charge m = 1.0 # mass B = np.array([0, 0, 1.0]) # uniform magnetic field E = np.array([0, 0, 0]) # no electric field v0 = np.array([1.0, 0.0, 1.0]) # velocity with component along B r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 T = 20 N = int(T / dt) # Arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Integrate using Euler method for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 3D Plot fig = plt.figure(figsize=(10,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_title('Helical Motion of a Charged Particle') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') plt.show() # Crossed fields: E in x-direction, B in z-direction E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([0.0, 1.0, 0.0]) # initial velocity # Reinitialize r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 2D Plot of Drift plt.figure(figsize=(8,6)) plt.plot(r[:,0], r[:,1]) plt.title('Drift Motion in Crossed Electric and Magnetic Fields') plt.xlabel('X') plt.ylabel('Y') plt.axis('equal') plt.grid(True) plt.show() visit website","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation: Calculating the equivalent resistance in an electrical circuit is a fundamental task in electrical engineering and physics. While traditional methods involve step-by-step application of series and parallel resistor rules, graph theory offers a more systematic approach for handling complex resistor networks. By representing the circuit as a graph, where nodes are junctions and edges represent resistors, we can simplify the process of finding the equivalent resistance, especially in circuits with complex or nested configurations. Algorithm Overview: The algorithm calculates the equivalent resistance in a circuit by reducing the graph iteratively. The key steps involve: Identifying Series Connections: Resistors connected end-to-end (in series) can be replaced by a single equivalent resistor, where the total resistance is the sum of individual resistances. Identifying Parallel Connections: Resistors connected in parallel can be replaced by an equivalent resistor using the parallel resistance formula: \ud835\udc45 eq = ( \u2211 1 \ud835\udc45 \ud835\udc56 ) \u2212 1 R eq \u200b =(\u2211 R i \u200b 1 \u200b ) \u22121 Iterative Reduction: The algorithm simplifies the graph by detecting and combining series and parallel resistors until only one edge (the equivalent resistance) remains. Algorithm Steps: Input: A graph representing the circuit, where each node is a junction and each edge is a resistor with a resistance value. Series and Parallel Reduction: For series resistors, combine their resistances by adding them. def series_circuit(*resistances): \"\"\" Calculate the equivalent resistance for resistors in series. :param resistances: List of resistor values in series. :return: Equivalent resistance \"\"\" return sum(resistances) # Example for A-B-C in series resistance_series = series_circuit(5, 10) # A\u2013B: 5\u03a9, B\u2013C: 10\u03a9 print(f\"Equivalent resistance for series circuit: {resistance_series} \u03a9\") Equivalent resistance for series circuit: 15 \u03a9 For parallel resistors, use the parallel formula to compute the equivalent resistance. def parallel_circuit(*resistances): \"\"\" Calculate the equivalent resistance for resistors in parallel. :param resistances: List of resistor values in parallel. :return: Equivalent resistance \"\"\" inverse_sum = sum(1 / r for r in resistances) return 1 / inverse_sum # Example for triangle circuit: A\u2013B = 6\u03a9, A\u2013C = 6\u03a9, B\u2013C = 3\u03a9 resistance_parallel = parallel_circuit(6, 6, 3) # Resistors in parallel print(f\"Equivalent resistance for parallel circuit: {resistance_parallel:.2f} \u03a9\") Equivalent resistance for parallel circuit: 1.50 \u03a9 Graph Update: After combining resistors, update the graph by replacing the combined resistors with their equivalent resistance, removing the individual resistors. Repeat: Continue reducing the graph until there is only one remaining edge, which represents the equivalent resistance of the entire circuit. Output: The equivalent resistance of the circuit. Pseudocode for Equivalent Resistance Calculation: plaintext Kopyala D\u00fczenle function calculate_equivalent_resistance(graph): while graph has more than one resistor: // Step 1: Identify and combine series resistors for each pair of nodes u and v connected by resistors: if u and v are in series: R_series = sum of resistances of connected resistors replace u-v connection with R_series in the graph // Step 2: Identify and combine parallel resistors for each pair of nodes u and v connected by resistors: if u and v are in parallel: R_parallel = 1 / (1/R1 + 1/R2 + ...) replace u-v connection with R_parallel in the graph // Repeat until only one resistor remains in the graph return the final equivalent resistance Explanation: Series Connection: Resistors in series share a single path, so their total resistance is the sum of the individual resistances: \ud835\udc45 eq = \ud835\udc45 1 + \ud835\udc45 2 + \u22ef R eq \u200b =R 1 \u200b +R 2 \u200b +\u22ef Parallel Connection: Resistors in parallel share two nodes and can be reduced using the formula: 1 \ud835\udc45 eq = 1 \ud835\udc45 1 + 1 \ud835\udc45 2 + \u22ef R eq \u200b 1 \u200b = R 1 \u200b 1 \u200b + R 2 \u200b 1 \u200b +\u22ef For two resistors in parallel: \ud835\udc45 eq = \ud835\udc45 1 \u22c5 \ud835\udc45 2 \ud835\udc45 1 + \ud835\udc45 2 R eq \u200b = R 1 \u200b +R 2 \u200b R 1 \u200b \u22c5R 2 \u200b \u200b Iterative Reduction: At each iteration, identify series or parallel connections and replace them with their equivalent resistances. The graph is updated to reflect the new resistor configuration after each reduction. This process continues until only one equivalent resistor remains. Handling Nested Configurations: Nested series and parallel configurations are handled by detecting combinations of series and parallel connections that can be simplified. After reducing one combination, the graph is re-evaluated to check if new series or parallel combinations appear due to the simplification. Complex Circuits: For circuits with multiple cycles and branches, the algorithm systematically reduces the graph while maintaining the relationships between resistors. Even in complex circuits, the algorithm ensures that each reduction step brings the graph closer to a single equivalent resistor. Example Inputs: Example 1: Simple Series Circuit Given a simple series circuit: css Kopyala D\u00fczenle A -- 2\u03a9 -- B -- 3\u03a9 -- C The algorithm detects that resistors between A and B, and B and C, are in series. The equivalent resistance between A and C is: \ud835\udc45 eq = 2 \u03a9 + 3 \u03a9 = 5 \u03a9 R eq \u200b =2\u03a9+3\u03a9=5\u03a9 Example 2: Simple Parallel Circuit Given a simple parallel circuit: less Kopyala D\u00fczenle A -- 2\u03a9 --+-- C | 3\u03a9 | B The algorithm detects that resistors between A and C, and C and B, are in parallel. The equivalent resistance is: \ud835\udc45 eq = 2 \u03a9 \u00d7 3 \u03a9 2 \u03a9 + 3 \u03a9 = 1.2 \u03a9 R eq \u200b = 2\u03a9+3\u03a9 2\u03a9\u00d73\u03a9 \u200b =1.2\u03a9 Example 3: Nested Series and Parallel Given a nested circuit: less Kopyala D\u00fczenle A -- 2\u03a9 --+-- B -- 4\u03a9 --+-- C | | 3\u03a9 6\u03a9 | | +--------------+ First, combine the resistors between B and C (which are in parallel): \ud835\udc45 BC = 4 \u03a9 \u00d7 6 \u03a9 4 \u03a9 + 6 \u03a9 = 2.4 \u03a9 R BC \u200b = 4\u03a9+6\u03a9 4\u03a9\u00d76\u03a9 \u200b =2.4\u03a9 Now, combine the resistors between A and B (in series with 3\u03a9 and 2.4\u03a9): \ud835\udc45 AB = 3 \u03a9 + 2.4 \u03a9 = 5.4 \u03a9 R AB \u200b =3\u03a9+2.4\u03a9=5.4\u03a9 Finally, combine the remaining series resistors A to C: \ud835\udc45 eq = 2 \u03a9 + 5.4 \u03a9 = 7.4 \u03a9 R eq \u200b =2\u03a9+5.4\u03a9=7.4\u03a9 Algorithm Efficiency: Time Complexity: The algorithm processes each edge of the graph multiple times. Each iteration reduces the number of resistors by merging series or parallel connections. In the worst case, the complexity can be \ud835\udc42 ( \ud835\udc38 ) O(E), where \ud835\udc38 E is the number of edges (resistors) in the graph. Space Complexity: The space complexity is \ud835\udc42 ( \ud835\udc49 + \ud835\udc38 ) O(V+E), where \ud835\udc49 V is the number of nodes (junctions) and \ud835\udc38 E is the number of edges (resistors). The graph's adjacency list is stored in memory. Potential Improvements: Optimized Parallelism: In circuits with many parallel paths, additional optimizations can be applied to detect and combine parallel resistors more efficiently. Graph Traversal: Depth-First Search (DFS) or Breadth-First Search (BFS) could be used to identify cycles and more complex subgraphs that might offer faster reduction. Caching Subgraphs: Caching intermediate results for subgraphs could improve efficiency for circuits with repeated substructures. Conclusion: Using graph theory to calculate equivalent resistance provides a structured, algorithmic way to analyze circuits. This approach can handle complex configurations, including nested series and parallel resistors, making it ideal for circuit analysis and simulation. The iterative graph simplification process ensures that the algorithm is scalable and efficient, even for large circuits. visit website","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"Motivation: Calculating the equivalent resistance in an electrical circuit is a fundamental task in electrical engineering and physics. While traditional methods involve step-by-step application of series and parallel resistor rules, graph theory offers a more systematic approach for handling complex resistor networks. By representing the circuit as a graph, where nodes are junctions and edges represent resistors, we can simplify the process of finding the equivalent resistance, especially in circuits with complex or nested configurations. Algorithm Overview: The algorithm calculates the equivalent resistance in a circuit by reducing the graph iteratively. The key steps involve: Identifying Series Connections: Resistors connected end-to-end (in series) can be replaced by a single equivalent resistor, where the total resistance is the sum of individual resistances. Identifying Parallel Connections: Resistors connected in parallel can be replaced by an equivalent resistor using the parallel resistance formula: \ud835\udc45 eq = ( \u2211 1 \ud835\udc45 \ud835\udc56 ) \u2212 1 R eq \u200b =(\u2211 R i \u200b 1 \u200b ) \u22121 Iterative Reduction: The algorithm simplifies the graph by detecting and combining series and parallel resistors until only one edge (the equivalent resistance) remains. Algorithm Steps: Input: A graph representing the circuit, where each node is a junction and each edge is a resistor with a resistance value. Series and Parallel Reduction: For series resistors, combine their resistances by adding them. def series_circuit(*resistances): \"\"\" Calculate the equivalent resistance for resistors in series. :param resistances: List of resistor values in series. :return: Equivalent resistance \"\"\" return sum(resistances) # Example for A-B-C in series resistance_series = series_circuit(5, 10) # A\u2013B: 5\u03a9, B\u2013C: 10\u03a9 print(f\"Equivalent resistance for series circuit: {resistance_series} \u03a9\") Equivalent resistance for series circuit: 15 \u03a9 For parallel resistors, use the parallel formula to compute the equivalent resistance. def parallel_circuit(*resistances): \"\"\" Calculate the equivalent resistance for resistors in parallel. :param resistances: List of resistor values in parallel. :return: Equivalent resistance \"\"\" inverse_sum = sum(1 / r for r in resistances) return 1 / inverse_sum # Example for triangle circuit: A\u2013B = 6\u03a9, A\u2013C = 6\u03a9, B\u2013C = 3\u03a9 resistance_parallel = parallel_circuit(6, 6, 3) # Resistors in parallel print(f\"Equivalent resistance for parallel circuit: {resistance_parallel:.2f} \u03a9\") Equivalent resistance for parallel circuit: 1.50 \u03a9 Graph Update: After combining resistors, update the graph by replacing the combined resistors with their equivalent resistance, removing the individual resistors. Repeat: Continue reducing the graph until there is only one remaining edge, which represents the equivalent resistance of the entire circuit. Output: The equivalent resistance of the circuit. Pseudocode for Equivalent Resistance Calculation: plaintext Kopyala D\u00fczenle function calculate_equivalent_resistance(graph): while graph has more than one resistor: // Step 1: Identify and combine series resistors for each pair of nodes u and v connected by resistors: if u and v are in series: R_series = sum of resistances of connected resistors replace u-v connection with R_series in the graph // Step 2: Identify and combine parallel resistors for each pair of nodes u and v connected by resistors: if u and v are in parallel: R_parallel = 1 / (1/R1 + 1/R2 + ...) replace u-v connection with R_parallel in the graph // Repeat until only one resistor remains in the graph return the final equivalent resistance Explanation: Series Connection: Resistors in series share a single path, so their total resistance is the sum of the individual resistances: \ud835\udc45 eq = \ud835\udc45 1 + \ud835\udc45 2 + \u22ef R eq \u200b =R 1 \u200b +R 2 \u200b +\u22ef Parallel Connection: Resistors in parallel share two nodes and can be reduced using the formula: 1 \ud835\udc45 eq = 1 \ud835\udc45 1 + 1 \ud835\udc45 2 + \u22ef R eq \u200b 1 \u200b = R 1 \u200b 1 \u200b + R 2 \u200b 1 \u200b +\u22ef For two resistors in parallel: \ud835\udc45 eq = \ud835\udc45 1 \u22c5 \ud835\udc45 2 \ud835\udc45 1 + \ud835\udc45 2 R eq \u200b = R 1 \u200b +R 2 \u200b R 1 \u200b \u22c5R 2 \u200b \u200b Iterative Reduction: At each iteration, identify series or parallel connections and replace them with their equivalent resistances. The graph is updated to reflect the new resistor configuration after each reduction. This process continues until only one equivalent resistor remains. Handling Nested Configurations: Nested series and parallel configurations are handled by detecting combinations of series and parallel connections that can be simplified. After reducing one combination, the graph is re-evaluated to check if new series or parallel combinations appear due to the simplification. Complex Circuits: For circuits with multiple cycles and branches, the algorithm systematically reduces the graph while maintaining the relationships between resistors. Even in complex circuits, the algorithm ensures that each reduction step brings the graph closer to a single equivalent resistor. Example Inputs: Example 1: Simple Series Circuit Given a simple series circuit: css Kopyala D\u00fczenle A -- 2\u03a9 -- B -- 3\u03a9 -- C The algorithm detects that resistors between A and B, and B and C, are in series. The equivalent resistance between A and C is: \ud835\udc45 eq = 2 \u03a9 + 3 \u03a9 = 5 \u03a9 R eq \u200b =2\u03a9+3\u03a9=5\u03a9 Example 2: Simple Parallel Circuit Given a simple parallel circuit: less Kopyala D\u00fczenle A -- 2\u03a9 --+-- C | 3\u03a9 | B The algorithm detects that resistors between A and C, and C and B, are in parallel. The equivalent resistance is: \ud835\udc45 eq = 2 \u03a9 \u00d7 3 \u03a9 2 \u03a9 + 3 \u03a9 = 1.2 \u03a9 R eq \u200b = 2\u03a9+3\u03a9 2\u03a9\u00d73\u03a9 \u200b =1.2\u03a9 Example 3: Nested Series and Parallel Given a nested circuit: less Kopyala D\u00fczenle A -- 2\u03a9 --+-- B -- 4\u03a9 --+-- C | | 3\u03a9 6\u03a9 | | +--------------+ First, combine the resistors between B and C (which are in parallel): \ud835\udc45 BC = 4 \u03a9 \u00d7 6 \u03a9 4 \u03a9 + 6 \u03a9 = 2.4 \u03a9 R BC \u200b = 4\u03a9+6\u03a9 4\u03a9\u00d76\u03a9 \u200b =2.4\u03a9 Now, combine the resistors between A and B (in series with 3\u03a9 and 2.4\u03a9): \ud835\udc45 AB = 3 \u03a9 + 2.4 \u03a9 = 5.4 \u03a9 R AB \u200b =3\u03a9+2.4\u03a9=5.4\u03a9 Finally, combine the remaining series resistors A to C: \ud835\udc45 eq = 2 \u03a9 + 5.4 \u03a9 = 7.4 \u03a9 R eq \u200b =2\u03a9+5.4\u03a9=7.4\u03a9 Algorithm Efficiency: Time Complexity: The algorithm processes each edge of the graph multiple times. Each iteration reduces the number of resistors by merging series or parallel connections. In the worst case, the complexity can be \ud835\udc42 ( \ud835\udc38 ) O(E), where \ud835\udc38 E is the number of edges (resistors) in the graph. Space Complexity: The space complexity is \ud835\udc42 ( \ud835\udc49 + \ud835\udc38 ) O(V+E), where \ud835\udc49 V is the number of nodes (junctions) and \ud835\udc38 E is the number of edges (resistors). The graph's adjacency list is stored in memory. Potential Improvements: Optimized Parallelism: In circuits with many parallel paths, additional optimizations can be applied to detect and combine parallel resistors more efficiently. Graph Traversal: Depth-First Search (DFS) or Breadth-First Search (BFS) could be used to identify cycles and more complex subgraphs that might offer faster reduction. Caching Subgraphs: Caching intermediate results for subgraphs could improve efficiency for circuits with repeated substructures. Conclusion: Using graph theory to calculate equivalent resistance provides a structured, algorithmic way to analyze circuits. This approach can handle complex configurations, including nested series and parallel resistors, making it ideal for circuit analysis and simulation. The iterative graph simplification process ensures that the algorithm is scalable and efficient, even for large circuits. visit website","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcd8 Exploring the Central Limit Theorem through Simulations \ud83c\udfaf Motivation The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states that the distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the shape of the original population distribution. This simulation project allows us to visually and computationally explore the CLT in action by drawing samples from different distributions and analyzing their sample means. def sample_means(population, sample_size, num_samples=1000): means = [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] return means np.random.choice(population, size=sample_size, replace=False) \ud83e\uddf0 Tools & Libraries We will use the following Python libraries: numpy for numerical computations matplotlib and seaborn for visualization matplotlib.animation for GIF generation \ud83d\udd22 1. Generating Population Distributions We simulate large populations from: - Uniform Distribution : Equal probability over a range - Exponential Distribution : Skewed distribution - Binomial Distribution : Discrete distribution fig, axs = plt.subplots(1, 3, figsize=(18, 5)) distributions = [ (\"Uniform\", uniform_pop, \"skyblue\"), (\"Exponential\", exponential_pop, \"orange\"), (\"Binomial\", binomial_pop, \"red\") ] for ax, (title, data, color) in zip(axs, distributions): sns.histplot(data, bins=50, kde=True, color=color, ax=ax) ax.set_title(f\"{title} Distribution\", fontsize=14) ax.set_xlabel(\"Value\") ax.set_ylabel(\"Frequency\") fig.suptitle(\"Population Distributions\", fontsize=18) plt.tight_layout() plt.show() \ud83d\udd04 2. Sampling and Visualization We repeatedly sample from each population, compute the sample means, and visualize the resulting sampling distribution for increasing sample sizes (5, 10, 30, 50). This allows us to observe how the distribution of the mean converges to normality. plt.title(f\"{dist_name} \u2014 Sample Size {sample_size}\", fontsize=12) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") sample_sizes = [5, 10, 30, 50] distributions = { 'Uniform': pop_uniform, 'Exponential': pop_exponential, 'Binomial': pop_binomial } for name, pop in distributions.items(): plt.figure(figsize=(14, 8)) for i, size in enumerate(sample_sizes): means = sample_means(pop, size) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, bins=30, color=\"skyblue\") plt.title(f\"{name} Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of Sample Mean for {name} Population\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.savefig(f\"{name}_CLT_Plot.png\") # Save as picture plt.show() \ud83d\udd2c 3. Parameter Exploration We also explore how sample size affects: - The shape of the sampling distribution - The variance (spread) of the sample means \ud83d\udd2c Parameter Exploration \u2013 Variance vs. Sample Size \ud83d\udcd8 Objective This section explores how increasing the sample size (n) affects the variance of the sample mean for different population distributions. According to the Central Limit Theorem (CLT) : As the sample size increases, the distribution of the sample mean becomes more concentrated around the population mean, and the variance of the sample mean decreases . \ud83d\udcd0 Mathematical Insight The variance of the sample mean is given by the formula: \\[ \\mathrm{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] Where: - $ \\sigma^2 $ is the population variance - $ n $ is the sample size - $ \\bar{X} $ is the sample mean This means that increasing the sample size reduces the spread of the sample mean distribution, making our estimates more precise . \ud83d\udcca Visualization We use the following population distributions: - Uniform Distribution : Equal probability between 0 and 1 - Exponential Distribution : Right-skewed, models time between events - Binomial Distribution : Discrete, counts number of successes in Bernoulli trials We compute and plot the variance of the sample mean for each distribution across sample sizes from 1 to 100. \ud83d\udd0d Expected Outcome All curves should decrease asymptotically , confirming the $ \\frac{1}{n} $ relationship. Even for skewed or discrete distributions, the behavior remains consistent. This demonstrates that the CLT applies universally as long as the sample size is sufficiently large. \u2705 Key Takeaways Larger samples lead to more stable estimates of the population mean. The sample mean becomes less variable as $ n $ increases. This phenomenon is distribution-independent , further validating the CLT. import numpy as np import matplotlib.pyplot as plt # Set seed and generate populations np.random.seed(42) N = 100_000 uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(scale=1.0, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Sample sizes to explore sample_sizes = np.arange(1, 101) # Calculate population variances var_uniform = np.var(uniform_pop) var_exponential = np.var(exponential_pop) var_binomial = np.var(binomial_pop) # Calculate theoretical sample mean variances sample_var_uniform = var_uniform / sample_sizes sample_var_exponential = var_exponential / sample_sizes sample_var_binomial = var_binomial / sample_sizes # Plotting plt.figure(figsize=(10, 6)) plt.plot(sample_sizes, sample_var_uniform, label=\"Uniform\", color=\"skyblue\", lw=2) plt.plot(sample_sizes, sample_var_exponential, label=\"Exponential\", color=\"orange\", lw=2) plt.plot(sample_sizes, sample_var_binomial, label=\"Binomial\", color=\"red\", lw=2) plt.title(\"\ud83d\udcc9 Variance of Sample Mean vs. Sample Size\", fontsize=14) plt.xlabel(\"Sample Size (n)\", fontsize=12) plt.ylabel(\"Variance of Sample Mean\", fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.legend(title=\"Distribution\") plt.tight_layout() plt.show() \ud83c\udfed 4. Practical Applications of the Central Limit Theorem The Central Limit Theorem (CLT) is not just a theoretical concept\u2014it powers many statistical applications in real life. Here are a few key areas: Field Application Example \ud83c\udfaf Polling Estimating election results from small surveys \ud83c\udfed Manufacturing Quality control using average measurements \ud83d\udc8a Medicine Comparing drug effectiveness in clinical trials \ud83d\udcbb Tech A/B testing website performance \ud83d\udcc8 Finance Predicting average returns on investments In all these cases, the CLT ensures that even if the underlying data is not normally distributed, the sample mean can be treated as approximately normal for inference and decision-making\u2014especially with large enough samples. Let\u2019s simulate how sampling enables accurate average estimation in a production-quality context. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Simulate a population (e.g., machine measurements in a factory) np.random.seed(42) true_pop = np.random.exponential(scale=5.0, size=100_000) # Simulate 1000 samples of different sizes sample_sizes = [5, 10, 30, 50, 100] mean_estimates = {} for n in sample_sizes: sample_means = [np.mean(np.random.choice(true_pop, size=n, replace=False)) for _ in range(1000)] mean_estimates[n] = sample_means # Plotting sampling distributions plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): plt.subplot(2, 3, i+1) sns.histplot(mean_estimates[n], bins=30, kde=True, color='mediumseagreen') plt.title(f\"Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.axvline(np.mean(true_pop), color='red', linestyle='--', label='True Mean') plt.legend() plt.suptitle(\"Sampling Distributions in a Manufacturing Scenario\", fontsize=16, weight='bold') plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() # Function to generate sample means for various sample sizes def generate_sample_means(population, sample_sizes, num_samples=1000): results = {} for n in sample_sizes: results[n] = sample_means(population, n, num_samples) return results import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Generate a large binomial population N = 100_000 n_trials = 10 # number of trials per binomial experiment p_success = 0.5 # probability of success binomial_pop = np.random.binomial(n=n_trials, p=p_success, size=N) # Function to generate sample means def sample_means(population, sample_size, num_samples=1000): means = [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] return means # Sample sizes to explore sample_sizes = [5, 10, 30, 50] # Plot sampling distributions of the sample mean for each sample size plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes, 1): means = sample_means(binomial_pop, size) plt.subplot(2, 2, i) sns.histplot(means, bins=30, kde=True, color=\"red\") plt.title(f\"Binomial Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(\"Sampling Distribution of Sample Means from Binomial Population\", fontsize=18) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() \u2705 Summary Distribution Skewness Convergence Speed Uniform None Fast Exponential High Moderate Binomial Low Fast \ud83d\udcbe Deliverables Python scripts for simulations Plots for sampling distributions Animated GIFs Markdown and notebook documentation visit web","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcd8 Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental theorem in probability and statistics. It states that the distribution of the sample mean approaches a normal distribution as the sample size increases, regardless of the shape of the original population distribution. This simulation project allows us to visually and computationally explore the CLT in action by drawing samples from different distributions and analyzing their sample means. def sample_means(population, sample_size, num_samples=1000): means = [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] return means np.random.choice(population, size=sample_size, replace=False)","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tools-libraries","text":"We will use the following Python libraries: numpy for numerical computations matplotlib and seaborn for visualization matplotlib.animation for GIF generation","title":"\ud83e\uddf0 Tools &amp; Libraries"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-generating-population-distributions","text":"We simulate large populations from: - Uniform Distribution : Equal probability over a range - Exponential Distribution : Skewed distribution - Binomial Distribution : Discrete distribution fig, axs = plt.subplots(1, 3, figsize=(18, 5)) distributions = [ (\"Uniform\", uniform_pop, \"skyblue\"), (\"Exponential\", exponential_pop, \"orange\"), (\"Binomial\", binomial_pop, \"red\") ] for ax, (title, data, color) in zip(axs, distributions): sns.histplot(data, bins=50, kde=True, color=color, ax=ax) ax.set_title(f\"{title} Distribution\", fontsize=14) ax.set_xlabel(\"Value\") ax.set_ylabel(\"Frequency\") fig.suptitle(\"Population Distributions\", fontsize=18) plt.tight_layout() plt.show()","title":"\ud83d\udd22 1. Generating Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"We repeatedly sample from each population, compute the sample means, and visualize the resulting sampling distribution for increasing sample sizes (5, 10, 30, 50). This allows us to observe how the distribution of the mean converges to normality. plt.title(f\"{dist_name} \u2014 Sample Size {sample_size}\", fontsize=12) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") sample_sizes = [5, 10, 30, 50] distributions = { 'Uniform': pop_uniform, 'Exponential': pop_exponential, 'Binomial': pop_binomial } for name, pop in distributions.items(): plt.figure(figsize=(14, 8)) for i, size in enumerate(sample_sizes): means = sample_means(pop, size) plt.subplot(2, 2, i+1) sns.histplot(means, kde=True, bins=30, color=\"skyblue\") plt.title(f\"{name} Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of Sample Mean for {name} Population\", fontsize=16) plt.tight_layout(rect=[0, 0, 1, 0.96]) plt.savefig(f\"{name}_CLT_Plot.png\") # Save as picture plt.show()","title":"\ud83d\udd04 2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"We also explore how sample size affects: - The shape of the sampling distribution - The variance (spread) of the sample means","title":"\ud83d\udd2c 3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration-variance-vs-sample-size","text":"","title":"\ud83d\udd2c Parameter Exploration \u2013 Variance vs. Sample Size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"This section explores how increasing the sample size (n) affects the variance of the sample mean for different population distributions. According to the Central Limit Theorem (CLT) : As the sample size increases, the distribution of the sample mean becomes more concentrated around the population mean, and the variance of the sample mean decreases .","title":"\ud83d\udcd8 Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#mathematical-insight","text":"The variance of the sample mean is given by the formula: \\[ \\mathrm{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] Where: - $ \\sigma^2 $ is the population variance - $ n $ is the sample size - $ \\bar{X} $ is the sample mean This means that increasing the sample size reduces the spread of the sample mean distribution, making our estimates more precise .","title":"\ud83d\udcd0 Mathematical Insight"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization","text":"We use the following population distributions: - Uniform Distribution : Equal probability between 0 and 1 - Exponential Distribution : Right-skewed, models time between events - Binomial Distribution : Discrete, counts number of successes in Bernoulli trials We compute and plot the variance of the sample mean for each distribution across sample sizes from 1 to 100.","title":"\ud83d\udcca Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#expected-outcome","text":"All curves should decrease asymptotically , confirming the $ \\frac{1}{n} $ relationship. Even for skewed or discrete distributions, the behavior remains consistent. This demonstrates that the CLT applies universally as long as the sample size is sufficiently large.","title":"\ud83d\udd0d Expected Outcome"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-takeaways","text":"Larger samples lead to more stable estimates of the population mean. The sample mean becomes less variable as $ n $ increases. This phenomenon is distribution-independent , further validating the CLT. import numpy as np import matplotlib.pyplot as plt # Set seed and generate populations np.random.seed(42) N = 100_000 uniform_pop = np.random.uniform(0, 1, N) exponential_pop = np.random.exponential(scale=1.0, size=N) binomial_pop = np.random.binomial(n=10, p=0.5, size=N) # Sample sizes to explore sample_sizes = np.arange(1, 101) # Calculate population variances var_uniform = np.var(uniform_pop) var_exponential = np.var(exponential_pop) var_binomial = np.var(binomial_pop) # Calculate theoretical sample mean variances sample_var_uniform = var_uniform / sample_sizes sample_var_exponential = var_exponential / sample_sizes sample_var_binomial = var_binomial / sample_sizes # Plotting plt.figure(figsize=(10, 6)) plt.plot(sample_sizes, sample_var_uniform, label=\"Uniform\", color=\"skyblue\", lw=2) plt.plot(sample_sizes, sample_var_exponential, label=\"Exponential\", color=\"orange\", lw=2) plt.plot(sample_sizes, sample_var_binomial, label=\"Binomial\", color=\"red\", lw=2) plt.title(\"\ud83d\udcc9 Variance of Sample Mean vs. Sample Size\", fontsize=14) plt.xlabel(\"Sample Size (n)\", fontsize=12) plt.ylabel(\"Variance of Sample Mean\", fontsize=12) plt.grid(True, linestyle='--', alpha=0.6) plt.legend(title=\"Distribution\") plt.tight_layout() plt.show()","title":"\u2705 Key Takeaways"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-the-central-limit-theorem","text":"The Central Limit Theorem (CLT) is not just a theoretical concept\u2014it powers many statistical applications in real life. Here are a few key areas: Field Application Example \ud83c\udfaf Polling Estimating election results from small surveys \ud83c\udfed Manufacturing Quality control using average measurements \ud83d\udc8a Medicine Comparing drug effectiveness in clinical trials \ud83d\udcbb Tech A/B testing website performance \ud83d\udcc8 Finance Predicting average returns on investments In all these cases, the CLT ensures that even if the underlying data is not normally distributed, the sample mean can be treated as approximately normal for inference and decision-making\u2014especially with large enough samples. Let\u2019s simulate how sampling enables accurate average estimation in a production-quality context. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Simulate a population (e.g., machine measurements in a factory) np.random.seed(42) true_pop = np.random.exponential(scale=5.0, size=100_000) # Simulate 1000 samples of different sizes sample_sizes = [5, 10, 30, 50, 100] mean_estimates = {} for n in sample_sizes: sample_means = [np.mean(np.random.choice(true_pop, size=n, replace=False)) for _ in range(1000)] mean_estimates[n] = sample_means # Plotting sampling distributions plt.figure(figsize=(15, 8)) for i, n in enumerate(sample_sizes): plt.subplot(2, 3, i+1) sns.histplot(mean_estimates[n], bins=30, kde=True, color='mediumseagreen') plt.title(f\"Sample Size {n}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.axvline(np.mean(true_pop), color='red', linestyle='--', label='True Mean') plt.legend() plt.suptitle(\"Sampling Distributions in a Manufacturing Scenario\", fontsize=16, weight='bold') plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show() # Function to generate sample means for various sample sizes def generate_sample_means(population, sample_sizes, num_samples=1000): results = {} for n in sample_sizes: results[n] = sample_means(population, n, num_samples) return results import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set random seed for reproducibility np.random.seed(42) # Generate a large binomial population N = 100_000 n_trials = 10 # number of trials per binomial experiment p_success = 0.5 # probability of success binomial_pop = np.random.binomial(n=n_trials, p=p_success, size=N) # Function to generate sample means def sample_means(population, sample_size, num_samples=1000): means = [np.mean(np.random.choice(population, size=sample_size, replace=False)) for _ in range(num_samples)] return means # Sample sizes to explore sample_sizes = [5, 10, 30, 50] # Plot sampling distributions of the sample mean for each sample size plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes, 1): means = sample_means(binomial_pop, size) plt.subplot(2, 2, i) sns.histplot(means, bins=30, kde=True, color=\"red\") plt.title(f\"Binomial Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(\"Sampling Distribution of Sample Means from Binomial Population\", fontsize=18) plt.tight_layout(rect=[0, 0, 1, 0.95]) plt.show()","title":"\ud83c\udfed 4. Practical Applications of the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"Distribution Skewness Convergence Speed Uniform None Fast Exponential High Moderate Binomial Low Fast","title":"\u2705 Summary"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"Python scripts for simulations Plots for sampling distributions Animated GIFs Markdown and notebook documentation visit web","title":"\ud83d\udcbe Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods \ud83c\udfaf Motivation Monte Carlo methods use random sampling to solve complex problems and estimate numerical values. One of their classic applications is estimating the value of \u03c0 (pi) via geometric probability. In this assignment, you will explore two different Monte Carlo approaches to estimate \u03c0: Part 1: Using random points inside a square and an inscribed circle. Part 2: Using Buffon\u2019s Needle experiment, a classic geometric probability problem. These methods illustrate how randomness can yield elegant solutions to deterministic mathematical constants. \ud83d\udfe0 Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Background Consider a unit circle (radius $ r = 1 $) inscribed inside a square with side length 2. The area of the square is: \\[ A_{\\text{square}} = 2^2 = 4 \\] The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\times 1^2 = \\pi \\] The probability $ P $ that a random point inside the square falls within the circle is the ratio of their areas: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Rearranging, \u03c0 can be estimated as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points}} \\] 2. Simulation Algorithm Generate $ N $ random points \\((x, y)\\) uniformly distributed inside the square \\([-1, 1] \\times [-1, 1]\\) . For each point, check if it lies inside the circle using: \\[ x^2 + y^2 \\leq 1 \\] Count how many points satisfy this condition. Calculate \u03c0 estimate using the formula above. 3. Visualization Plot all points: Points inside the circle in blue . Points outside the circle in red . Draw the boundary of the unit circle. Display the estimated \u03c0 value in the plot title. 4. Convergence Analysis Repeat the experiment for different $ N $ values, e.g., 100, 1,000, 10,000, 100,000. Plot estimated \u03c0 values against $ N $ on a log scale. Plot the absolute error $ |\\pi - \\hat{\\pi}| $ versus $ N $. \ud83e\uddf5 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Background Buffon's Needle is a classical probability experiment: A needle of length $ L $ is dropped onto a floor with parallel lines spaced $ D $ units apart, where $ L \\leq D $. The probability $ P $ that the needle crosses one of the lines is: \\[ P = \\frac{2L}{\\pi D} \\] If we drop the needle $ N $ times and observe $ H $ hits (crossings), \u03c0 can be estimated as: \\[ \\pi \\approx \\frac{2 L N}{D H} \\] 2. Simulation Algorithm For each drop: Randomly generate the center position of the needle between two lines. Randomly generate the angle \\( \\theta \\in [0, \\pi] \\) of the needle with respect to the parallel lines. Determine whether the needle crosses a line based on its position and angle. Count the number of hits \\( H \\) . Calculate the \u03c0 estimate. 3. Visualization Draw the parallel lines horizontally. Plot each needle: Needles crossing a line in red . Needles not crossing in gray . Show the estimated \u03c0 value on the plot. 4. Convergence Analysis Run simulations for varying $ N $ (e.g., 100, 500, 1,000, 5,000, 10,000). Plot the estimated \u03c0 versus $ N $. Analyze and discuss the variance and convergence speed compared to the circle method. \u2696\ufe0f Comparison and Discussion Method Convergence Speed Accuracy Complexity Visualization Clarity Circle-based Fast High Simple High Buffon\u2019s Needle Slower Moderate Moderate Moderate The circle method converges faster and is easier to implement and visualize. Buffon\u2019s Needle is mathematically elegant and historically significant, but converges slower and has more variance. \u2705 Deliverables Python code implementing both methods. Plots showing: Points and needles visualizations. Convergence graphs for different sample sizes. Comparative analysis and discussion of results. \ud83d\udcda References Monte Carlo Method - Wikipedia Buffon\u2019s Needle Problem - Wikipedia Allen B. Downey, Think Stats Appendix: Python Code Examples def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate import numpy as np import matplotlib.pyplot as plt Part 1: Circle Method import numpy as np import matplotlib.pyplot as plt def plot_points_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') circle = plt.Circle((0,0), 1, fill=False, color='green', linewidth=2) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(f\"Points inside/outside unit circle (n={num_points})\") plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: plot_points_circle(10000) def plot_pi_convergence_circle(sample_sizes): estimates = [] for n in sample_sizes: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n estimates.append(pi_estimate) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimation using Monte Carlo Circle Method') plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: sample_sizes = [100, 1000, 5000, 10000, 50000] plot_pi_convergence_circle(sample_sizes) def plot_pi_error_circle(sample_sizes): errors = [] for n in sample_sizes: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n error = abs(np.pi - pi_estimate) errors.append(error) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, errors, marker='o', color='red') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Absolute Error') plt.title('Error in Pi Estimation (Circle Method)') plt.grid(True) plt.show() # Kullan\u0131m: plot_pi_error_circle(sample_sizes) Part 2: Buffon's Needle def plot_buffon_needle(N, L=1.0, D=2.0): x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) crosses = x_centers <= (L/2) * np.sin(angles) plt.figure(figsize=(8,6)) for i in range(N): x = x_centers[i] theta = angles[i] x0 = x - (L/2)*np.cos(theta) x1 = x + (L/2)*np.cos(theta) y0 = i % 50 y1 = y0 + L * np.sin(theta) color = 'red' if crosses[i] else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line_pos in np.arange(0, 60, D): plt.axvline(line_pos, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle Simulation (N={N})\") plt.xlabel('X') plt.ylabel('Needle drop index (mod 50)') plt.grid(True) plt.show() # Kullan\u0131m: plot_buffon_needle(5000) def buffon_needle_simulation(N, L=1.0, D=2.0): hits = 0 x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) for i in range(N): if x_centers[i] <= (L / 2) * np.sin(angles[i]): hits += 1 if hits == 0: return None # Avoid division by zero pi_estimate = (2 * L * N) / (D * hits) # Visualization plt.figure(figsize=(8, 6)) for i in range(N): x = x_centers[i] theta = angles[i] x0 = x - (L/2) * np.cos(theta) x1 = x + (L/2) * np.cos(theta) y0 = i % 50 y1 = y0 + np.sin(theta) * L color = 'red' if x <= (L / 2) * np.sin(theta) else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line in np.arange(0, 10, D): plt.axvline(line, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle: \u03c0 \u2248 {pi_estimate:.5f} (N={N})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() return pi_estimate # Example Usage: estimate_pi_circle(10000) buffon_needle_simulation(5000) def plot_pi_convergence_buffon(sample_sizes, L=1.0, D=2.0): estimates = [] for N in sample_sizes: x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) crosses = x_centers <= (L/2) * np.sin(angles) hits = np.sum(crosses) if hits == 0: pi_estimate = np.nan else: pi_estimate = (2 * L * N) / (D * hits) estimates.append(pi_estimate) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xlabel('Number of Needle Drops') plt.ylabel('Estimated Pi') plt.title(\"Convergence of Pi Estimation via Buffon's Needle\") plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: sample_sizes_needle = [100, 500, 1000, 5000, 10000] plot_pi_convergence_buffon(sample_sizes_needle) visit web","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-using-monte-carlo-methods","text":"","title":"Problem 2: Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo methods use random sampling to solve complex problems and estimate numerical values. One of their classic applications is estimating the value of \u03c0 (pi) via geometric probability. In this assignment, you will explore two different Monte Carlo approaches to estimate \u03c0: Part 1: Using random points inside a square and an inscribed circle. Part 2: Using Buffon\u2019s Needle experiment, a classic geometric probability problem. These methods illustrate how randomness can yield elegant solutions to deterministic mathematical constants.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"\ud83d\udfe0 Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-background","text":"Consider a unit circle (radius $ r = 1 $) inscribed inside a square with side length 2. The area of the square is: \\[ A_{\\text{square}} = 2^2 = 4 \\] The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\times 1^2 = \\pi \\] The probability $ P $ that a random point inside the square falls within the circle is the ratio of their areas: \\[ P = \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] Rearranging, \u03c0 can be estimated as: \\[ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points}} \\]","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-algorithm","text":"Generate $ N $ random points \\((x, y)\\) uniformly distributed inside the square \\([-1, 1] \\times [-1, 1]\\) . For each point, check if it lies inside the circle using: \\[ x^2 + y^2 \\leq 1 \\] Count how many points satisfy this condition. Calculate \u03c0 estimate using the formula above.","title":"2. Simulation Algorithm"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Plot all points: Points inside the circle in blue . Points outside the circle in red . Draw the boundary of the unit circle. Display the estimated \u03c0 value in the plot title.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-convergence-analysis","text":"Repeat the experiment for different $ N $ values, e.g., 100, 1,000, 10,000, 100,000. Plot estimated \u03c0 values against $ N $ on a log scale. Plot the absolute error $ |\\pi - \\hat{\\pi}| $ versus $ N $.","title":"4. Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"\ud83e\uddf5 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-background_1","text":"Buffon's Needle is a classical probability experiment: A needle of length $ L $ is dropped onto a floor with parallel lines spaced $ D $ units apart, where $ L \\leq D $. The probability $ P $ that the needle crosses one of the lines is: \\[ P = \\frac{2L}{\\pi D} \\] If we drop the needle $ N $ times and observe $ H $ hits (crossings), \u03c0 can be estimated as: \\[ \\pi \\approx \\frac{2 L N}{D H} \\]","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation-algorithm_1","text":"For each drop: Randomly generate the center position of the needle between two lines. Randomly generate the angle \\( \\theta \\in [0, \\pi] \\) of the needle with respect to the parallel lines. Determine whether the needle crosses a line based on its position and angle. Count the number of hits \\( H \\) . Calculate the \u03c0 estimate.","title":"2. Simulation Algorithm"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Draw the parallel lines horizontally. Plot each needle: Needles crossing a line in red . Needles not crossing in gray . Show the estimated \u03c0 value on the plot.","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-convergence-analysis_1","text":"Run simulations for varying $ N $ (e.g., 100, 500, 1,000, 5,000, 10,000). Plot the estimated \u03c0 versus $ N $. Analyze and discuss the variance and convergence speed compared to the circle method.","title":"4. Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-and-discussion","text":"Method Convergence Speed Accuracy Complexity Visualization Clarity Circle-based Fast High Simple High Buffon\u2019s Needle Slower Moderate Moderate Moderate The circle method converges faster and is easier to implement and visualize. Buffon\u2019s Needle is mathematically elegant and historically significant, but converges slower and has more variance.","title":"\u2696\ufe0f Comparison and Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"Python code implementing both methods. Plots showing: Points and needles visualizations. Convergence graphs for different sample sizes. Comparative analysis and discussion of results.","title":"\u2705 Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#references","text":"Monte Carlo Method - Wikipedia Buffon\u2019s Needle Problem - Wikipedia Allen B. Downey, Think Stats","title":"\ud83d\udcda References"},{"location":"1%20Physics/6%20Statistics/Problem_2/#appendix-python-code-examples","text":"def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate import numpy as np import matplotlib.pyplot as plt","title":"Appendix: Python Code Examples"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-circle-method","text":"import numpy as np import matplotlib.pyplot as plt def plot_points_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') circle = plt.Circle((0,0), 1, fill=False, color='green', linewidth=2) plt.gca().add_artist(circle) plt.gca().set_aspect('equal') plt.title(f\"Points inside/outside unit circle (n={num_points})\") plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: plot_points_circle(10000) def plot_pi_convergence_circle(sample_sizes): estimates = [] for n in sample_sizes: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n estimates.append(pi_estimate) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated Pi') plt.title('Convergence of Pi Estimation using Monte Carlo Circle Method') plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: sample_sizes = [100, 1000, 5000, 10000, 50000] plot_pi_convergence_circle(sample_sizes) def plot_pi_error_circle(sample_sizes): errors = [] for n in sample_sizes: x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / n error = abs(np.pi - pi_estimate) errors.append(error) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, errors, marker='o', color='red') plt.xscale('log') plt.yscale('log') plt.xlabel('Number of Points (log scale)') plt.ylabel('Absolute Error') plt.title('Error in Pi Estimation (Circle Method)') plt.grid(True) plt.show() # Kullan\u0131m: plot_pi_error_circle(sample_sizes)","title":"Part 1: Circle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-buffons-needle","text":"def plot_buffon_needle(N, L=1.0, D=2.0): x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) crosses = x_centers <= (L/2) * np.sin(angles) plt.figure(figsize=(8,6)) for i in range(N): x = x_centers[i] theta = angles[i] x0 = x - (L/2)*np.cos(theta) x1 = x + (L/2)*np.cos(theta) y0 = i % 50 y1 = y0 + L * np.sin(theta) color = 'red' if crosses[i] else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line_pos in np.arange(0, 60, D): plt.axvline(line_pos, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle Simulation (N={N})\") plt.xlabel('X') plt.ylabel('Needle drop index (mod 50)') plt.grid(True) plt.show() # Kullan\u0131m: plot_buffon_needle(5000) def buffon_needle_simulation(N, L=1.0, D=2.0): hits = 0 x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) for i in range(N): if x_centers[i] <= (L / 2) * np.sin(angles[i]): hits += 1 if hits == 0: return None # Avoid division by zero pi_estimate = (2 * L * N) / (D * hits) # Visualization plt.figure(figsize=(8, 6)) for i in range(N): x = x_centers[i] theta = angles[i] x0 = x - (L/2) * np.cos(theta) x1 = x + (L/2) * np.cos(theta) y0 = i % 50 y1 = y0 + np.sin(theta) * L color = 'red' if x <= (L / 2) * np.sin(theta) else 'gray' plt.plot([x0, x1], [y0, y1], color=color, linewidth=0.8) for line in np.arange(0, 10, D): plt.axvline(line, color='black', linestyle='--', alpha=0.4) plt.title(f\"Buffon's Needle: \u03c0 \u2248 {pi_estimate:.5f} (N={N})\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.grid(True) plt.show() return pi_estimate # Example Usage: estimate_pi_circle(10000) buffon_needle_simulation(5000) def plot_pi_convergence_buffon(sample_sizes, L=1.0, D=2.0): estimates = [] for N in sample_sizes: x_centers = np.random.uniform(0, D/2, N) angles = np.random.uniform(0, np.pi/2, N) crosses = x_centers <= (L/2) * np.sin(angles) hits = np.sum(crosses) if hits == 0: pi_estimate = np.nan else: pi_estimate = (2 * L * N) / (D * hits) estimates.append(pi_estimate) plt.figure(figsize=(10,5)) plt.plot(sample_sizes, estimates, marker='o', linestyle='-', label='Estimated Pi') plt.axhline(np.pi, color='green', linestyle='--', label='Actual Pi') plt.xlabel('Number of Needle Drops') plt.ylabel('Estimated Pi') plt.title(\"Convergence of Pi Estimation via Buffon's Needle\") plt.legend() plt.grid(True) plt.show() # Kullan\u0131m: sample_sizes_needle = [100, 500, 1000, 5000, 10000] plot_pi_convergence_buffon(sample_sizes_needle) visit web","title":"Part 2: Buffon's Needle"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"\ud83c\udf0d Measuring Earth's Gravitational Acceleration Using a Pendulum \ud83e\udded 1. Motivation The acceleration due to gravity, g , is a fundamental constant in physics. It affects phenomena ranging from free fall to planetary orbits. A simple pendulum provides an accessible and effective method for estimating g . This experiment also introduces uncertainty analysis \u2014 an essential aspect of scientific measurements. \ud83e\uddea 2. Materials A string (~1.14 meters) USB power adapter (pendulum bob) Smartphone stopwatch Ruler or measuring tape (\u00b11 mm resolution) \u2699\ufe0f 3. Experimental Setup A small initial angle (<15\u00b0) ensured simple harmonic motion. Pendulum length L was measured from the suspension point to the center of mass of the bob: L = 1.140 m , u L = \u00b10.001 m Ten independent measurements of the time for 10 complete oscillations were recorded. # \ud83d\udd27 Import necessary libraries import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # \ud83d\udcd0 Physical Constants g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.14 # length of the pendulum (meters) theta0 = np.radians(10) # initial angle in radians (10 degrees) # \u23f1\ufe0f Time setup T = 2 * np.pi * np.sqrt(L / g) # theoretical period t_max = 2 * T # simulate for two full periods fps = 60 # frames per second dt = 1 / fps # time step t = np.arange(0, t_max, dt) # time array # \ud83c\udf00 Small angle approximation: \u03b8(t) = \u03b8\u2080 cos(\u221a(g/L) t) theta = theta0 * np.cos(np.sqrt(g / L) * t) # \ud83d\udccd Convert to Cartesian coordinates x = L * np.sin(theta) y = -L * np.cos(theta) # \ud83c\udfac Create the animation fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-L - 0.2, L + 0.2) ax.set_ylim(-L - 0.2, 0.2) ax.set_aspect('equal') ax.grid() # Draw pendulum components line, = ax.plot([], [], 'o-', lw=2, color='blue') # rod + bob trace, = ax.plot([], [], 'r--', lw=1, alpha=0.5) # trace of motion trace_x, trace_y = [], [] # \ud83d\uddbc\ufe0f Initialize function for animation def init(): line.set_data([], []) trace.set_data([], []) return line, trace # \ud83e\udde9 Animation function def update(frame): this_x = [0, x[frame]] this_y = [0, y[frame]] line.set_data(this_x, this_y) trace_x.append(x[frame]) trace_y.append(y[frame]) trace.set_data(trace_x, trace_y) return line, trace # \ud83c\udf9e\ufe0f Run the animation ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True, interval=1000*dt) # \ud83c\udfa5 Display in notebook from IPython.display import HTML HTML(ani.to_jshtml()) \ud83d\udcca 4. Data Collection 4.1 Raw Time Measurements (10 Oscillations) Trial Time (s) 1 18.05 2 17.65 3 18.12 4 17.92 5 17.98 6 18.01 7 17.83 8 18.00 9 17.91 10 18.07 \ud83e\uddee 5. Data Analysis 5.1 Mean and Standard Deviation \\[ \\bar{T}_{10} = 17.954 \\, \\text{s}, \\quad s = 0.136 \\, \\text{s} \\] Uncertainty in the mean: \\[ u_{\\bar{T}_{10}} = \\frac{0.136}{\\sqrt{10}} = 0.043 \\, \\text{s} \\] 5.2 Period of One Oscillation \\[ T = \\frac{\\bar{T}_{10}}{10} = 1.7954 \\, \\text{s}, \\quad u_T = \\frac{0.043}{10} = 0.0043 \\, \\text{s} \\] \ud83c\udf0d 6. Estimating Gravitational Acceleration Using the pendulum formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substituting values: \\[ g = \\frac{4\\pi^2 \\cdot 1.14}{(1.7954)^2} = 13.962 \\, \\text{m/s}^2 \\] 6.1 Propagating Uncertainty \\[ u_g = g \\cdot \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T}\\right)^2} \\] \\[ u_g = 13.962 \\cdot \\sqrt{\\left(\\frac{0.001}{1.14}\\right)^2 + \\left(2 \\cdot \\frac{0.0043}{1.7954}\\right)^2} = 0.068 \\, \\text{m/s}^2 \\] \ud83d\udccb 7. Results Summary Quantity Value Uncertainty Units Length (L) 1.140 \u00b10.001 m Period (T) 1.7954 \u00b10.0043 s Gravity (g) 13.962 \u00b10.068 m/s\u00b2 \ud83d\udcc8 8. Visual Data Representation (Note: The following are suggested visuals to include in your report or notebook.) Histogram of 10-oscillation times Time vs. trial number plot Comparison bar chart between experimental and standard g \ud83d\udd0d 9. Discussion 9.1 Comparison with Standard Value The standard gravitational acceleration at sea level is: \\[ g_0 = 9.80665 \\, \\text{m/s}^2 \\] Our measured value ( 13.962 m/s\u00b2 ) significantly exceeds this and lies well outside the uncertainty range, suggesting systematic error . 9.2 Sources of Uncertainty and Error Source Effect Manual timing Human reaction time introduces bias Length measurement Small errors significantly affect result Large swing angle Violates small-angle assumption Non-vertical swing Introduces complexity and error 9.3 How to Improve the Experiment Use photogate timers for accurate timing Measure length precisely with calipers or laser tools Keep oscillations under 10\u00b0 for harmonic motion Increase number of trials and average over larger datasets \u2705 10. Conclusion Although simple, this experiment highlights the importance of precision and error analysis . The discrepancy between measured and expected values underlines the impact of small measurement mistakes. Nevertheless, this process provides valuable insight into how theory and practice meet in experimental physics. \ud83d\udcda 11. References Serway, R. A., & Jewett, J. W. (2014). Physics for Scientists and Engineers . Taylor, J. R. (1997). An Introduction to Error Analysis . OpenAI ChatGPT Experimental Lab (2025) import numpy as np import matplotlib.pyplot as plt # Raw time measurements for 10 oscillations (seconds) T10_data = np.array([18.05, 17.65, 18.12, 17.92, 17.98, 18.01, 17.83, 18.00, 17.91, 18.07]) # Pendulum length and uncertainty L = 1.14 # meters u_L = 0.001 # uncertainty in length (meters) n = len(T10_data) # Calculate mean, standard deviation, and uncertainty in the mean mean_T10 = np.mean(T10_data) std_T10 = np.std(T10_data, ddof=1) u_mean_T10 = std_T10 / np.sqrt(n) # Period for one oscillation and uncertainty T = mean_T10 / 10 u_T = u_mean_T10 / 10 # Calculate gravitational acceleration and uncertainty g_exp = (4 * np.pi**2 * L) / T**2 u_g = g_exp * np.sqrt((u_L / L)**2 + (2 * u_T / T)**2) print(f\"Mean time for 10 oscillations: {mean_T10:.3f} \u00b1 {u_mean_T10:.3f} s\") print(f\"Period of one oscillation: {T:.4f} \u00b1 {u_T:.4f} s\") print(f\"Calculated g: {g_exp:.3f} \u00b1 {u_g:.3f} m/s\u00b2\") Mean time for 10 oscillations: 17.954 \u00b1 0.043 s Period of one oscillation: 1.7954 \u00b1 0.0043 s Calculated g: 13.962 \u00b1 0.068 m/s\u00b2 plt.figure(figsize=(8, 5)) plt.scatter(range(1, n + 1), T10_data, color='blue', label='10 Oscillations Time Measurements') plt.hlines(mean_T10, 1, n, colors='red', linestyles='dashed', label=f'Mean = {mean_T10:.3f} s') plt.fill_between([1, n], mean_T10 - u_mean_T10, mean_T10 + u_mean_T10, color='red', alpha=0.2, label='Uncertainty in Mean') plt.xlabel('Trial Number') plt.ylabel('Time for 10 oscillations (s)') plt.title('Pendulum Timing Measurements') plt.legend() plt.grid(True) plt.show() plt.figure(figsize=(7, 5)) plt.hist(T10_data, bins=5, color='skyblue', edgecolor='black') plt.axvline(mean_T10, color='red', linestyle='dashed', label='Mean') plt.xlabel('Time for 10 oscillations (s)') plt.ylabel('Frequency') plt.title('Histogram of Timing Measurements') plt.legend() plt.grid(True) plt.show() plt.figure(figsize=(5, 5)) plt.errorbar(1, g_exp, yerr=u_g, fmt='o', color='green', capsize=5, label=f'Measured g = {g_exp:.3f} \u00b1 {u_g:.3f} m/s\u00b2') plt.axhline(9.80665, color='blue', linestyle='--', label='Standard g = 9.80665 m/s\u00b2') plt.xlim(0, 2) plt.xticks([]) plt.ylabel('Acceleration due to gravity (m/s\u00b2)') plt.title('Measured Gravitational Acceleration') plt.legend() plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters g = 9.81 # gravity (m/s^2) L = 1.14 # length of pendulum (m) theta0_deg = 10 # initial angle in degrees theta0 = np.radians(theta0_deg) damping = 0.01 # small damping coefficient # Time settings fps = 60 T0 = 2 * np.pi * np.sqrt(L / g) # theoretical period t_max = 3 * T0 # run for 3 full periods dt = 1 / fps t = np.arange(0, t_max, dt) # Damped angular displacement (small angle approx) omega0 = np.sqrt(g / L) theta = theta0 * np.exp(-damping * t) * np.cos(omega0 * t) # Cartesian coordinates of the bob x = L * np.sin(theta) y = -L * np.cos(theta) # Setup plot fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-L - 0.3, L + 0.3) ax.set_ylim(-L - 0.3, 0.3) ax.set_aspect('equal') ax.grid(True) ax.set_title('Pendulum Experiment Simulation') ax.set_xlabel('x (meters)') ax.set_ylabel('y (meters)') # Draw fixed pivot pivot_radius = 0.03 pivot = plt.Circle((0, 0), pivot_radius, fc='k') ax.add_patch(pivot) # Draw protractor arc (showing initial angle) angle_arc = np.linspace(0, theta0, 100) arc_x = 0.25 * np.sin(angle_arc) arc_y = 0.25 * np.cos(angle_arc) ax.plot(arc_x, arc_y, 'orange', lw=3, label='Initial angle ~10\u00b0') # Text label for initial angle ax.text(0.15, 0.05, f'{theta0_deg}\u00b0', color='orange', fontsize=12) # Pendulum rod and bob initialization line, = ax.plot([], [], lw=3, color='brown') bob_radius = 0.07 bob = plt.Circle((0, 0), bob_radius, fc='red', ec='black', lw=1) ax.add_patch(bob) # Trail variables (fading trail) trail_len = 50 # number of points in trail trail_x, trail_y = [], [] trail_dots = [ax.plot([], [], 'ro', alpha=0.5)[0] for _ in range(trail_len)] # Stopwatch display time_text = ax.text(0.7, 0.9, '', transform=ax.transAxes, fontsize=14, bbox=dict(facecolor='white', alpha=0.8)) def init(): line.set_data([], []) bob.center = (0, 0) for dot in trail_dots: dot.set_data([], []) dot.set_alpha(0) time_text.set_text('') return [line, bob, time_text] + trail_dots def update(frame): # Pendulum position this_x = [0, x[frame]] this_y = [0, y[frame]] line.set_data(this_x, this_y) bob.center = (x[frame], y[frame]) # Update trail trail_x.append(x[frame]) trail_y.append(y[frame]) if len(trail_x) > trail_len: trail_x.pop(0) trail_y.pop(0) for i, dot in enumerate(trail_dots): if i < len(trail_x): dot.set_data([trail_x[i]], [trail_y[i]]) # Pass as a list dot.set_alpha(i / trail_len) else: dot.set_alpha(0) # Update stopwatch timer text time_text.set_text(f'Time: {t[frame]:.2f} s') return [line, bob, time_text] + trail_dots ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True, interval=1000*dt) HTML(ani.to_jshtml()) I did this experiment with my necklace, and it took 10 seconds to complete 10 periods. To measure this, I used the stopwatch on my other phone. visit web","title":"\ud83c\udf0d Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-using-a-pendulum","text":"","title":"\ud83c\udf0d Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-motivation","text":"The acceleration due to gravity, g , is a fundamental constant in physics. It affects phenomena ranging from free fall to planetary orbits. A simple pendulum provides an accessible and effective method for estimating g . This experiment also introduces uncertainty analysis \u2014 an essential aspect of scientific measurements.","title":"\ud83e\udded 1. Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-materials","text":"A string (~1.14 meters) USB power adapter (pendulum bob) Smartphone stopwatch Ruler or measuring tape (\u00b11 mm resolution)","title":"\ud83e\uddea 2. Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-experimental-setup","text":"A small initial angle (<15\u00b0) ensured simple harmonic motion. Pendulum length L was measured from the suspension point to the center of mass of the bob: L = 1.140 m , u L = \u00b10.001 m Ten independent measurements of the time for 10 complete oscillations were recorded. # \ud83d\udd27 Import necessary libraries import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # \ud83d\udcd0 Physical Constants g = 9.81 # gravitational acceleration (m/s\u00b2) L = 1.14 # length of the pendulum (meters) theta0 = np.radians(10) # initial angle in radians (10 degrees) # \u23f1\ufe0f Time setup T = 2 * np.pi * np.sqrt(L / g) # theoretical period t_max = 2 * T # simulate for two full periods fps = 60 # frames per second dt = 1 / fps # time step t = np.arange(0, t_max, dt) # time array # \ud83c\udf00 Small angle approximation: \u03b8(t) = \u03b8\u2080 cos(\u221a(g/L) t) theta = theta0 * np.cos(np.sqrt(g / L) * t) # \ud83d\udccd Convert to Cartesian coordinates x = L * np.sin(theta) y = -L * np.cos(theta) # \ud83c\udfac Create the animation fig, ax = plt.subplots(figsize=(6, 6)) ax.set_xlim(-L - 0.2, L + 0.2) ax.set_ylim(-L - 0.2, 0.2) ax.set_aspect('equal') ax.grid() # Draw pendulum components line, = ax.plot([], [], 'o-', lw=2, color='blue') # rod + bob trace, = ax.plot([], [], 'r--', lw=1, alpha=0.5) # trace of motion trace_x, trace_y = [], [] # \ud83d\uddbc\ufe0f Initialize function for animation def init(): line.set_data([], []) trace.set_data([], []) return line, trace # \ud83e\udde9 Animation function def update(frame): this_x = [0, x[frame]] this_y = [0, y[frame]] line.set_data(this_x, this_y) trace_x.append(x[frame]) trace_y.append(y[frame]) trace.set_data(trace_x, trace_y) return line, trace # \ud83c\udf9e\ufe0f Run the animation ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True, interval=1000*dt) # \ud83c\udfa5 Display in notebook from IPython.display import HTML HTML(ani.to_jshtml())","title":"\u2699\ufe0f 3. Experimental Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-data-collection","text":"","title":"\ud83d\udcca 4. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#41-raw-time-measurements-10-oscillations","text":"Trial Time (s) 1 18.05 2 17.65 3 18.12 4 17.92 5 17.98 6 18.01 7 17.83 8 18.00 9 17.91 10 18.07","title":"4.1 Raw Time Measurements (10 Oscillations)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-data-analysis","text":"","title":"\ud83e\uddee 5. Data Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#51-mean-and-standard-deviation","text":"\\[ \\bar{T}_{10} = 17.954 \\, \\text{s}, \\quad s = 0.136 \\, \\text{s} \\] Uncertainty in the mean: \\[ u_{\\bar{T}_{10}} = \\frac{0.136}{\\sqrt{10}} = 0.043 \\, \\text{s} \\]","title":"5.1 Mean and Standard Deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#52-period-of-one-oscillation","text":"\\[ T = \\frac{\\bar{T}_{10}}{10} = 1.7954 \\, \\text{s}, \\quad u_T = \\frac{0.043}{10} = 0.0043 \\, \\text{s} \\]","title":"5.2 Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#6-estimating-gravitational-acceleration","text":"Using the pendulum formula: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Substituting values: \\[ g = \\frac{4\\pi^2 \\cdot 1.14}{(1.7954)^2} = 13.962 \\, \\text{m/s}^2 \\]","title":"\ud83c\udf0d 6. Estimating Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#61-propagating-uncertainty","text":"\\[ u_g = g \\cdot \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T}\\right)^2} \\] \\[ u_g = 13.962 \\cdot \\sqrt{\\left(\\frac{0.001}{1.14}\\right)^2 + \\left(2 \\cdot \\frac{0.0043}{1.7954}\\right)^2} = 0.068 \\, \\text{m/s}^2 \\]","title":"6.1 Propagating Uncertainty"},{"location":"1%20Physics/7%20Measurements/Problem_1/#7-results-summary","text":"Quantity Value Uncertainty Units Length (L) 1.140 \u00b10.001 m Period (T) 1.7954 \u00b10.0043 s Gravity (g) 13.962 \u00b10.068 m/s\u00b2","title":"\ud83d\udccb 7. Results Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#8-visual-data-representation","text":"(Note: The following are suggested visuals to include in your report or notebook.) Histogram of 10-oscillation times Time vs. trial number plot Comparison bar chart between experimental and standard g","title":"\ud83d\udcc8 8. Visual Data Representation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#9-discussion","text":"","title":"\ud83d\udd0d 9. Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#91-comparison-with-standard-value","text":"The standard gravitational acceleration at sea level is: \\[ g_0 = 9.80665 \\, \\text{m/s}^2 \\] Our measured value ( 13.962 m/s\u00b2 ) significantly exceeds this and lies well outside the uncertainty range, suggesting systematic error .","title":"9.1 Comparison with Standard Value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#92-sources-of-uncertainty-and-error","text":"Source Effect Manual timing Human reaction time introduces bias Length measurement Small errors significantly affect result Large swing angle Violates small-angle assumption Non-vertical swing Introduces complexity and error","title":"9.2 Sources of Uncertainty and Error"},{"location":"1%20Physics/7%20Measurements/Problem_1/#93-how-to-improve-the-experiment","text":"Use photogate timers for accurate timing Measure length precisely with calipers or laser tools Keep oscillations under 10\u00b0 for harmonic motion Increase number of trials and average over larger datasets","title":"9.3 How to Improve the Experiment"},{"location":"1%20Physics/7%20Measurements/Problem_1/#10-conclusion","text":"Although simple, this experiment highlights the importance of precision and error analysis . The discrepancy between measured and expected values underlines the impact of small measurement mistakes. Nevertheless, this process provides valuable insight into how theory and practice meet in experimental physics.","title":"\u2705 10. Conclusion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#11-references","text":"Serway, R. A., & Jewett, J. W. (2014). Physics for Scientists and Engineers . Taylor, J. R. (1997). An Introduction to Error Analysis . OpenAI ChatGPT Experimental Lab (2025) import numpy as np import matplotlib.pyplot as plt # Raw time measurements for 10 oscillations (seconds) T10_data = np.array([18.05, 17.65, 18.12, 17.92, 17.98, 18.01, 17.83, 18.00, 17.91, 18.07]) # Pendulum length and uncertainty L = 1.14 # meters u_L = 0.001 # uncertainty in length (meters) n = len(T10_data) # Calculate mean, standard deviation, and uncertainty in the mean mean_T10 = np.mean(T10_data) std_T10 = np.std(T10_data, ddof=1) u_mean_T10 = std_T10 / np.sqrt(n) # Period for one oscillation and uncertainty T = mean_T10 / 10 u_T = u_mean_T10 / 10 # Calculate gravitational acceleration and uncertainty g_exp = (4 * np.pi**2 * L) / T**2 u_g = g_exp * np.sqrt((u_L / L)**2 + (2 * u_T / T)**2) print(f\"Mean time for 10 oscillations: {mean_T10:.3f} \u00b1 {u_mean_T10:.3f} s\") print(f\"Period of one oscillation: {T:.4f} \u00b1 {u_T:.4f} s\") print(f\"Calculated g: {g_exp:.3f} \u00b1 {u_g:.3f} m/s\u00b2\") Mean time for 10 oscillations: 17.954 \u00b1 0.043 s Period of one oscillation: 1.7954 \u00b1 0.0043 s Calculated g: 13.962 \u00b1 0.068 m/s\u00b2 plt.figure(figsize=(8, 5)) plt.scatter(range(1, n + 1), T10_data, color='blue', label='10 Oscillations Time Measurements') plt.hlines(mean_T10, 1, n, colors='red', linestyles='dashed', label=f'Mean = {mean_T10:.3f} s') plt.fill_between([1, n], mean_T10 - u_mean_T10, mean_T10 + u_mean_T10, color='red', alpha=0.2, label='Uncertainty in Mean') plt.xlabel('Trial Number') plt.ylabel('Time for 10 oscillations (s)') plt.title('Pendulum Timing Measurements') plt.legend() plt.grid(True) plt.show() plt.figure(figsize=(7, 5)) plt.hist(T10_data, bins=5, color='skyblue', edgecolor='black') plt.axvline(mean_T10, color='red', linestyle='dashed', label='Mean') plt.xlabel('Time for 10 oscillations (s)') plt.ylabel('Frequency') plt.title('Histogram of Timing Measurements') plt.legend() plt.grid(True) plt.show() plt.figure(figsize=(5, 5)) plt.errorbar(1, g_exp, yerr=u_g, fmt='o', color='green', capsize=5, label=f'Measured g = {g_exp:.3f} \u00b1 {u_g:.3f} m/s\u00b2') plt.axhline(9.80665, color='blue', linestyle='--', label='Standard g = 9.80665 m/s\u00b2') plt.xlim(0, 2) plt.xticks([]) plt.ylabel('Acceleration due to gravity (m/s\u00b2)') plt.title('Measured Gravitational Acceleration') plt.legend() plt.grid(True) plt.show() import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters g = 9.81 # gravity (m/s^2) L = 1.14 # length of pendulum (m) theta0_deg = 10 # initial angle in degrees theta0 = np.radians(theta0_deg) damping = 0.01 # small damping coefficient # Time settings fps = 60 T0 = 2 * np.pi * np.sqrt(L / g) # theoretical period t_max = 3 * T0 # run for 3 full periods dt = 1 / fps t = np.arange(0, t_max, dt) # Damped angular displacement (small angle approx) omega0 = np.sqrt(g / L) theta = theta0 * np.exp(-damping * t) * np.cos(omega0 * t) # Cartesian coordinates of the bob x = L * np.sin(theta) y = -L * np.cos(theta) # Setup plot fig, ax = plt.subplots(figsize=(7, 7)) ax.set_xlim(-L - 0.3, L + 0.3) ax.set_ylim(-L - 0.3, 0.3) ax.set_aspect('equal') ax.grid(True) ax.set_title('Pendulum Experiment Simulation') ax.set_xlabel('x (meters)') ax.set_ylabel('y (meters)') # Draw fixed pivot pivot_radius = 0.03 pivot = plt.Circle((0, 0), pivot_radius, fc='k') ax.add_patch(pivot) # Draw protractor arc (showing initial angle) angle_arc = np.linspace(0, theta0, 100) arc_x = 0.25 * np.sin(angle_arc) arc_y = 0.25 * np.cos(angle_arc) ax.plot(arc_x, arc_y, 'orange', lw=3, label='Initial angle ~10\u00b0') # Text label for initial angle ax.text(0.15, 0.05, f'{theta0_deg}\u00b0', color='orange', fontsize=12) # Pendulum rod and bob initialization line, = ax.plot([], [], lw=3, color='brown') bob_radius = 0.07 bob = plt.Circle((0, 0), bob_radius, fc='red', ec='black', lw=1) ax.add_patch(bob) # Trail variables (fading trail) trail_len = 50 # number of points in trail trail_x, trail_y = [], [] trail_dots = [ax.plot([], [], 'ro', alpha=0.5)[0] for _ in range(trail_len)] # Stopwatch display time_text = ax.text(0.7, 0.9, '', transform=ax.transAxes, fontsize=14, bbox=dict(facecolor='white', alpha=0.8)) def init(): line.set_data([], []) bob.center = (0, 0) for dot in trail_dots: dot.set_data([], []) dot.set_alpha(0) time_text.set_text('') return [line, bob, time_text] + trail_dots def update(frame): # Pendulum position this_x = [0, x[frame]] this_y = [0, y[frame]] line.set_data(this_x, this_y) bob.center = (x[frame], y[frame]) # Update trail trail_x.append(x[frame]) trail_y.append(y[frame]) if len(trail_x) > trail_len: trail_x.pop(0) trail_y.pop(0) for i, dot in enumerate(trail_dots): if i < len(trail_x): dot.set_data([trail_x[i]], [trail_y[i]]) # Pass as a list dot.set_alpha(i / trail_len) else: dot.set_alpha(0) # Update stopwatch timer text time_text.set_text(f'Time: {t[frame]:.2f} s') return [line, bob, time_text] + trail_dots ani = FuncAnimation(fig, update, frames=len(t), init_func=init, blit=True, interval=1000*dt) HTML(ani.to_jshtml()) I did this experiment with my necklace, and it took 10 seconds to complete 10 periods. To measure this, I used the stopwatch on my other phone. visit web","title":"\ud83d\udcda 11. References"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}